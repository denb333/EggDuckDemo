import { Debug } from '../../../core/debug.js';
import { hasAudioContext } from '../../../platform/audio/capabilities.js';
import { Component } from '../component.js';
import { ComponentSystem } from '../system.js';
import { SoundComponent } from './component.js';
import { SoundComponentData } from './data.js';

/**
 * @import { AppBase } from '../../app-base.js'
 * @import { SoundManager } from '../../../platform/sound/manager.js'
 */ var _schema = [
    'enabled'
];
/**
 * Manages creation of {@link SoundComponent}s.
 *
 * @category Sound
 */ class SoundComponentSystem extends ComponentSystem {
    /**
     * Sets the volume for the entire Sound system. All sounds will have their volume multiplied by
     * this value. Valid between [0, 1].
     *
     * @type {number}
     */ set volume(volume) {
        this.manager.volume = volume;
    }
    /**
     * Gets the volume for the entire Sound system.
     *
     * @type {number}
     */ get volume() {
        return this.manager.volume;
    }
    /**
     * Gets the AudioContext currently used by the sound manager. Requires Web Audio API support.
     * Returns null if the device does not support the Web Audio API.
     *
     * @type {AudioContext|null}
     */ get context() {
        if (!hasAudioContext()) {
            Debug.warn('WARNING: Audio context is not supported on this browser');
            return null;
        }
        return this.manager.context;
    }
    initializeComponentData(component, data, properties) {
        properties = [
            'volume',
            'pitch',
            'positional',
            'refDistance',
            'maxDistance',
            'rollOffFactor',
            'distanceModel',
            'slots'
        ];
        for(var i = 0; i < properties.length; i++){
            if (data.hasOwnProperty(properties[i])) {
                component[properties[i]] = data[properties[i]];
            }
        }
        super.initializeComponentData(component, data, [
            'enabled'
        ]);
    }
    cloneComponent(entity, clone) {
        var srcComponent = entity.sound;
        var srcSlots = srcComponent.slots;
        // convert 'slots' back to
        // simple option objects
        var slots = {};
        for(var key in srcSlots){
            var srcSlot = srcSlots[key];
            slots[key] = {
                name: srcSlot.name,
                volume: srcSlot.volume,
                pitch: srcSlot.pitch,
                loop: srcSlot.loop,
                duration: srcSlot.duration,
                startTime: srcSlot.startTime,
                overlap: srcSlot.overlap,
                autoPlay: srcSlot.autoPlay,
                asset: srcSlot.asset
            };
        }
        var cloneData = {
            distanceModel: srcComponent.distanceModel,
            enabled: srcComponent.enabled,
            maxDistance: srcComponent.maxDistance,
            pitch: srcComponent.pitch,
            positional: srcComponent.positional,
            refDistance: srcComponent.refDistance,
            rollOffFactor: srcComponent.rollOffFactor,
            slots: slots,
            volume: srcComponent.volume
        };
        // add component with new data
        return this.addComponent(clone, cloneData);
    }
    onUpdate(dt) {
        var store = this.store;
        for(var id in store){
            if (store.hasOwnProperty(id)) {
                var item = store[id];
                var entity = item.entity;
                if (entity.enabled) {
                    var component = entity.sound;
                    // Update slot position if this is a 3d sound
                    if (component.enabled && component.positional) {
                        var position = entity.getPosition();
                        var slots = component.slots;
                        for(var key in slots){
                            slots[key].updatePosition(position);
                        }
                    }
                }
            }
        }
    }
    onBeforeRemove(entity, component) {
        var slots = component.slots;
        // stop non overlapping sounds
        for(var key in slots){
            if (!slots[key].overlap) {
                slots[key].stop();
            }
        }
        component.onRemove();
    }
    destroy() {
        super.destroy();
        this.app.systems.off('update', this.onUpdate, this);
    }
    /**
     * Create a SoundComponentSystem.
     *
     * @param {AppBase} app - The Application.
     * @ignore
     */ constructor(app){
        super(app);
        this.id = 'sound';
        this.ComponentType = SoundComponent;
        this.DataType = SoundComponentData;
        this.schema = _schema;
        /**
         * Gets / sets the sound manager.
         *
         * @type {SoundManager}
         */ this.manager = app.soundManager;
        Debug.assert(this.manager, 'SoundComponentSystem cannot be created without sound manager');
        this.app.systems.on('update', this.onUpdate, this);
        this.on('beforeremove', this.onBeforeRemove, this);
    }
}
Component._buildAccessors(SoundComponent.prototype, _schema);

export { SoundComponentSystem };
