import { RenderPassShaderQuad } from '../../scene/graphics/render-pass-shader-quad.js';

/**
 * @import { GraphicsDevice } from '../../platform/graphics/graphics-device.js'
 * @import { Texture } from '../../platform/graphics/texture.js'
 */ /**
 * Render pass implementation of a down-sample filter.
 *
 * @category Graphics
 * @ignore
 */ class RenderPassDownsample extends RenderPassShaderQuad {
    setSourceTexture(value) {
        this._sourceTexture = value;
        // change resize source
        this.options.resizeSource = value;
    }
    execute() {
        this.sourceTextureId.setValue(this.sourceTexture);
        if (this.premultiplyTexture) {
            this.premultiplyTextureId.setValue(this.premultiplyTexture);
        }
        this.sourceInvResolutionValue[0] = 1.0 / this.sourceTexture.width;
        this.sourceInvResolutionValue[1] = 1.0 / this.sourceTexture.height;
        this.sourceInvResolutionId.setValue(this.sourceInvResolutionValue);
        super.execute();
    }
    /**
     * @param {GraphicsDevice} device - The graphics device.
     * @param {Texture} sourceTexture - The source texture to downsample.
     * @param {object} [options] - The options for the render pass.
     * @param {boolean} [options.boxFilter] - Whether to use a box filter for downsampling.
     * @param {Texture|null} [options.premultiplyTexture] - The texture to premultiply the source texture
     * with. Only supported when boxFilter is true.
     * @param {string} [options.premultiplySrcChannel] - The source channel to premultiply.
     */ constructor(device, sourceTexture, options = {}){
        super(device);
        this.sourceTexture = sourceTexture;
        this.premultiplyTexture = options.premultiplyTexture;
        var _options_boxFilter;
        var boxFilter = (_options_boxFilter = options.boxFilter) != null ? _options_boxFilter : false;
        var _options_premultiplySrcChannel;
        var key = (boxFilter ? 'Box' : '') + "-" + (options.premultiplyTexture ? 'Premultiply' : '') + "-" + ((_options_premultiplySrcChannel = options.premultiplySrcChannel) != null ? _options_premultiplySrcChannel : '') + "}";
        this.shader = this.createQuadShader("DownSampleShader:" + key, /* glsl */ "\n\n            " + (boxFilter ? '#define BOXFILTER' : '') + "\n            " + (options.premultiplyTexture ? '#define PREMULTIPLY' : '') + "\n\n            uniform sampler2D sourceTexture;\n            uniform vec2 sourceInvResolution;\n            varying vec2 uv0;\n\n            #ifdef PREMULTIPLY\n                uniform sampler2D premultiplyTexture;\n            #endif\n\n            void main()\n            {\n                vec3 e = texture2D (sourceTexture, vec2 (uv0.x, uv0.y)).rgb;\n\n                #ifdef BOXFILTER\n                    vec3 value = e;\n\n                    #ifdef PREMULTIPLY\n                        float premultiply = texture2D(premultiplyTexture, vec2 (uv0.x, uv0.y))." + options.premultiplySrcChannel + ";\n                        value *= vec3(premultiply);\n                    #endif\n                #else\n\n                    float x = sourceInvResolution.x;\n                    float y = sourceInvResolution.y;\n\n                    vec3 a = texture2D(sourceTexture, vec2 (uv0.x - 2.0 * x, uv0.y + 2.0 * y)).rgb;\n                    vec3 b = texture2D(sourceTexture, vec2 (uv0.x,           uv0.y + 2.0 * y)).rgb;\n                    vec3 c = texture2D(sourceTexture, vec2 (uv0.x + 2.0 * x, uv0.y + 2.0 * y)).rgb;\n\n                    vec3 d = texture2D(sourceTexture, vec2 (uv0.x - 2.0 * x, uv0.y)).rgb;\n                    vec3 f = texture2D(sourceTexture, vec2 (uv0.x + 2.0 * x, uv0.y)).rgb;\n\n                    vec3 g = texture2D(sourceTexture, vec2 (uv0.x - 2.0 * x, uv0.y - 2.0 * y)).rgb;\n                    vec3 h = texture2D(sourceTexture, vec2 (uv0.x,           uv0.y - 2.0 * y)).rgb;\n                    vec3 i = texture2D(sourceTexture, vec2 (uv0.x + 2.0 * x, uv0.y - 2.0 * y)).rgb;\n\n                    vec3 j = texture2D(sourceTexture, vec2 (uv0.x - x, uv0.y + y)).rgb;\n                    vec3 k = texture2D(sourceTexture, vec2 (uv0.x + x, uv0.y + y)).rgb;\n                    vec3 l = texture2D(sourceTexture, vec2 (uv0.x - x, uv0.y - y)).rgb;\n                    vec3 m = texture2D(sourceTexture, vec2 (uv0.x + x, uv0.y - y)).rgb;\n\n\n                    vec3 value = e * 0.125;\n                    value += (a + c + g + i) * 0.03125;\n                    value += (b + d + f + h) * 0.0625;\n                    value += (j + k + l + m) * 0.125;\n                #endif\n\n                gl_FragColor = vec4(value, 1.0);\n            }");
        this.sourceTextureId = device.scope.resolve('sourceTexture');
        this.premultiplyTextureId = device.scope.resolve('premultiplyTexture');
        this.sourceInvResolutionId = device.scope.resolve('sourceInvResolution');
        this.sourceInvResolutionValue = new Float32Array(2);
    }
}

export { RenderPassDownsample };
