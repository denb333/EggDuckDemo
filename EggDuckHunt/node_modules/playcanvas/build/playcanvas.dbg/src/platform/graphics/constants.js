/**
 * Ignores the integer part of texture coordinates, using only the fractional part.
 *
 * @type {number}
 * @category Graphics
 */ var ADDRESS_REPEAT = 0;
/**
 * Clamps texture coordinate to the range 0 to 1.
 *
 * @type {number}
 * @category Graphics
 */ var ADDRESS_CLAMP_TO_EDGE = 1;
/**
 * Texture coordinate to be set to the fractional part if the integer part is even. If the integer
 * part is odd, then the texture coordinate is set to 1 minus the fractional part.
 *
 * @type {number}
 * @category Graphics
 */ var ADDRESS_MIRRORED_REPEAT = 2;
/**
 * Multiply all fragment components by zero.
 *
 * @type {number}
 * @category Graphics
 */ var BLENDMODE_ZERO = 0;
/**
 * Multiply all fragment components by one.
 *
 * @type {number}
 * @category Graphics
 */ var BLENDMODE_ONE = 1;
/**
 * Multiply all fragment components by the components of the source fragment.
 *
 * @type {number}
 * @category Graphics
 */ var BLENDMODE_SRC_COLOR = 2;
/**
 * Multiply all fragment components by one minus the components of the source fragment.
 *
 * @type {number}
 * @category Graphics
 */ var BLENDMODE_ONE_MINUS_SRC_COLOR = 3;
/**
 * Multiply all fragment components by the components of the destination fragment.
 *
 * @type {number}
 * @category Graphics
 */ var BLENDMODE_DST_COLOR = 4;
/**
 * Multiply all fragment components by one minus the components of the destination fragment.
 *
 * @type {number}
 * @category Graphics
 */ var BLENDMODE_ONE_MINUS_DST_COLOR = 5;
/**
 * Multiply all fragment components by the alpha value of the source fragment.
 *
 * @type {number}
 * @category Graphics
 */ var BLENDMODE_SRC_ALPHA = 6;
/**
 * Multiply all fragment components by the alpha value of the source fragment.
 *
 * @type {number}
 * @category Graphics
 */ var BLENDMODE_SRC_ALPHA_SATURATE = 7;
/**
 * Multiply all fragment components by one minus the alpha value of the source fragment.
 *
 * @type {number}
 * @category Graphics
 */ var BLENDMODE_ONE_MINUS_SRC_ALPHA = 8;
/**
 * Multiply all fragment components by the alpha value of the destination fragment.
 *
 * @type {number}
 * @category Graphics
 */ var BLENDMODE_DST_ALPHA = 9;
/**
 * Multiply all fragment components by one minus the alpha value of the destination fragment.
 *
 * @type {number}
 * @category Graphics
 */ var BLENDMODE_ONE_MINUS_DST_ALPHA = 10;
/**
 * Multiplies all fragment components by a constant.
 *
 * @type {number}
 * @category Graphics
 */ var BLENDMODE_CONSTANT = 11;
/**
 * Multiplies all fragment components by 1 minus a constant.
 *
 * @type {number}
 * @category Graphics
 */ var BLENDMODE_ONE_MINUS_CONSTANT = 12;
/**
 * Add the results of the source and destination fragment multiplies.
 *
 * @type {number}
 * @category Graphics
 */ var BLENDEQUATION_ADD = 0;
/**
 * Subtract the results of the source and destination fragment multiplies.
 *
 * @type {number}
 * @category Graphics
 */ var BLENDEQUATION_SUBTRACT = 1;
/**
 * Reverse and subtract the results of the source and destination fragment multiplies.
 *
 * @type {number}
 * @category Graphics
 */ var BLENDEQUATION_REVERSE_SUBTRACT = 2;
/**
 * Use the smallest value.
 *
 * @type {number}
 * @category Graphics
 */ var BLENDEQUATION_MIN = 3;
/**
 * Use the largest value.
 *
 * @type {number}
 * @category Graphics
 */ var BLENDEQUATION_MAX = 4;
/**
 * A flag utilized during the construction of a {@link StorageBuffer} to make it available for read
 * access by CPU.
 *
 * @type {number}
 * @category Graphics
 */ var BUFFERUSAGE_READ = 0x0001;
/**
 * A flag utilized during the construction of a {@link StorageBuffer} to make it available for write
 * access by CPU.
 *
 * @type {number}
 * @category Graphics
 */ var BUFFERUSAGE_WRITE = 0x0002;
/**
 * A flag utilized during the construction of a {@link StorageBuffer} to ensure its compatibility
 * when used as a source of a copy operation.
 *
 * @type {number}
 * @category Graphics
 */ var BUFFERUSAGE_COPY_SRC = 0x0004;
/**
 * A flag utilized during the construction of a {@link StorageBuffer} to ensure its compatibility
 * when used as a destination of a copy operation, or as a target of a write operation.
 *
 * @type {number}
 * @category Graphics
 */ var BUFFERUSAGE_COPY_DST = 0x0008;
/**
 * A flag utilized during the construction of a {@link StorageBuffer} to ensure its compatibility
 * when used as an index buffer.
 *
 * @type {number}
 * @category Graphics
 */ var BUFFERUSAGE_INDEX = 0x0010;
/**
 * A flag utilized during the construction of a {@link StorageBuffer} to ensure its compatibility
 * when used as a vertex buffer.
 *
 * @type {number}
 * @category Graphics
 */ var BUFFERUSAGE_VERTEX = 0x0020;
/**
 * A flag utilized during the construction of a {@link StorageBuffer} to ensure its compatibility
 * when used as an uniform buffer.
 *
 * @type {number}
 * @category Graphics
 */ var BUFFERUSAGE_UNIFORM = 0x0040;
/**
 * An internal flag utilized during the construction of a {@link StorageBuffer} to ensure its
 * compatibility when used as a storage buffer.
 * This flag is hidden as it's automatically used by the StorageBuffer constructor.
 *
 * @type {number}
 * @category Graphics
 * @ignore
 */ var BUFFERUSAGE_STORAGE = 0x0080;
/**
 * A flag utilized during the construction of a {@link StorageBuffer} to allow it to store indirect
 * command arguments.
 * TODO: This flag is hidden till the feature is implemented.
 *
 * @type {number}
 * @category Graphics
 * @ignore
 */ var BUFFERUSAGE_INDIRECT = 0x0100;
/**
 * The data store contents will be modified once and used many times.
 *
 * @type {number}
 * @category Graphics
 */ var BUFFER_STATIC = 0;
/**
 * The data store contents will be modified repeatedly and used many times.
 *
 * @type {number}
 * @category Graphics
 */ var BUFFER_DYNAMIC = 1;
/**
 * The data store contents will be modified once and used at most a few times.
 *
 * @type {number}
 * @category Graphics
 */ var BUFFER_STREAM = 2;
/**
 * The data store contents will be modified repeatedly on the GPU and used many times. Optimal for
 * transform feedback usage.
 *
 * @type {number}
 * @category Graphics
 */ var BUFFER_GPUDYNAMIC = 3;
/**
 * Clear the color buffer.
 *
 * @type {number}
 * @category Graphics
 */ var CLEARFLAG_COLOR = 1;
/**
 * Clear the depth buffer.
 *
 * @type {number}
 * @category Graphics
 */ var CLEARFLAG_DEPTH = 2;
/**
 * Clear the stencil buffer.
 *
 * @type {number}
 * @category Graphics
 */ var CLEARFLAG_STENCIL = 4;
/**
 * The positive X face of a cubemap.
 *
 * @type {number}
 * @category Graphics
 */ var CUBEFACE_POSX = 0;
/**
 * The negative X face of a cubemap.
 *
 * @type {number}
 * @category Graphics
 */ var CUBEFACE_NEGX = 1;
/**
 * The positive Y face of a cubemap.
 *
 * @type {number}
 * @category Graphics
 */ var CUBEFACE_POSY = 2;
/**
 * The negative Y face of a cubemap.
 *
 * @type {number}
 * @category Graphics
 */ var CUBEFACE_NEGY = 3;
/**
 * The positive Z face of a cubemap.
 *
 * @type {number}
 * @category Graphics
 */ var CUBEFACE_POSZ = 4;
/**
 * The negative Z face of a cubemap.
 *
 * @type {number}
 * @category Graphics
 */ var CUBEFACE_NEGZ = 5;
/**
 * No triangles are culled.
 *
 * @type {number}
 * @category Graphics
 */ var CULLFACE_NONE = 0;
/**
 * Triangles facing away from the view direction are culled.
 *
 * @type {number}
 * @category Graphics
 */ var CULLFACE_BACK = 1;
/**
 * Triangles facing the view direction are culled.
 *
 * @type {number}
 * @category Graphics
 */ var CULLFACE_FRONT = 2;
/**
 * Triangles are culled regardless of their orientation with respect to the view direction. Note
 * that point or line primitives are unaffected by this render state.
 *
 * @type {number}
 * @ignore
 * @category Graphics
 */ var CULLFACE_FRONTANDBACK = 3;
/**
 * Point sample filtering.
 *
 * @type {number}
 * @category Graphics
 */ var FILTER_NEAREST = 0;
/**
 * Bilinear filtering.
 *
 * @type {number}
 * @category Graphics
 */ var FILTER_LINEAR = 1;
/**
 * Use the nearest neighbor in the nearest mipmap level.
 *
 * @type {number}
 * @category Graphics
 */ var FILTER_NEAREST_MIPMAP_NEAREST = 2;
/**
 * Linearly interpolate in the nearest mipmap level.
 *
 * @type {number}
 * @category Graphics
 */ var FILTER_NEAREST_MIPMAP_LINEAR = 3;
/**
 * Use the nearest neighbor after linearly interpolating between mipmap levels.
 *
 * @type {number}
 * @category Graphics
 */ var FILTER_LINEAR_MIPMAP_NEAREST = 4;
/**
 * Linearly interpolate both the mipmap levels and between texels.
 *
 * @type {number}
 * @category Graphics
 */ var FILTER_LINEAR_MIPMAP_LINEAR = 5;
/**
 * Never pass.
 *
 * @type {number}
 * @category Graphics
 */ var FUNC_NEVER = 0;
/**
 * Pass if (ref & mask) < (stencil & mask).
 *
 * @type {number}
 * @category Graphics
 */ var FUNC_LESS = 1;
/**
 * Pass if (ref & mask) == (stencil & mask).
 *
 * @type {number}
 * @category Graphics
 */ var FUNC_EQUAL = 2;
/**
 * Pass if (ref & mask) <= (stencil & mask).
 *
 * @type {number}
 * @category Graphics
 */ var FUNC_LESSEQUAL = 3;
/**
 * Pass if (ref & mask) > (stencil & mask).
 *
 * @type {number}
 * @category Graphics
 */ var FUNC_GREATER = 4;
/**
 * Pass if (ref & mask) != (stencil & mask).
 *
 * @type {number}
 * @category Graphics
 */ var FUNC_NOTEQUAL = 5;
/**
 * Pass if (ref & mask) >= (stencil & mask).
 *
 * @type {number}
 * @category Graphics
 */ var FUNC_GREATEREQUAL = 6;
/**
 * Always pass.
 *
 * @type {number}
 * @category Graphics
 */ var FUNC_ALWAYS = 7;
/**
 * 8-bit unsigned vertex indices (0 to 255).
 *
 * @type {number}
 * @category Graphics
 */ var INDEXFORMAT_UINT8 = 0;
/**
 * 16-bit unsigned vertex indices (0 to 65,535).
 *
 * @type {number}
 * @category Graphics
 */ var INDEXFORMAT_UINT16 = 1;
/**
 * 32-bit unsigned vertex indices (0 to 4,294,967,295).
 *
 * @type {number}
 * @category Graphics
 */ var INDEXFORMAT_UINT32 = 2;
var PIXELFORMAT_A8 = 0;
var PIXELFORMAT_L8 = 1;
var PIXELFORMAT_LA8 = 2;
/**
 * 16-bit RGB (5-bits for red channel, 6 for green and 5 for blue).
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_RGB565 = 3;
/**
 * 16-bit RGBA (5-bits for red channel, 5 for green, 5 for blue with 1-bit alpha).
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_RGBA5551 = 4;
/**
 * 16-bit RGBA (4-bits for red channel, 4 for green, 4 for blue with 4-bit alpha).
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_RGBA4 = 5;
/**
 * 24-bit RGB (8-bits for red channel, 8 for green and 8 for blue).
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_RGB8 = 6;
/**
 * 32-bit RGBA (8-bits for red channel, 8 for green, 8 for blue with 8-bit alpha).
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_RGBA8 = 7;
/**
 * Block compressed format storing 16 input pixels in 64 bits of output, consisting of two 16-bit
 * RGB 5:6:5 color values and a 4x4 two bit lookup table.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_DXT1 = 8;
/**
 * Block compressed format storing 16 input pixels (corresponding to a 4x4 pixel block) into 128
 * bits of output, consisting of 64 bits of alpha channel data (4 bits for each pixel) followed by
 * 64 bits of color data; encoded the same way as DXT1.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_DXT3 = 9;
/**
 * Block compressed format storing 16 input pixels into 128 bits of output, consisting of 64 bits
 * of alpha channel data (two 8 bit alpha values and a 4x4 3 bit lookup table) followed by 64 bits
 * of color data (encoded the same way as DXT1).
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_DXT5 = 10;
/**
 * 16-bit floating point RGB (16-bit float for each red, green and blue channels).
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_RGB16F = 11;
/**
 * 16-bit floating point RGBA (16-bit float for each red, green, blue and alpha channels).
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_RGBA16F = 12;
/**
 * 32-bit floating point RGB (32-bit float for each red, green and blue channels).
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_RGB32F = 13;
/**
 * 32-bit floating point RGBA (32-bit float for each red, green, blue and alpha channels).
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_RGBA32F = 14;
/**
 * 32-bit floating point single channel format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_R32F = 15;
/**
 * A readable depth buffer format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_DEPTH = 16;
/**
 * A readable depth/stencil buffer format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_DEPTHSTENCIL = 17;
/**
 * A floating-point color-only format with 11 bits for red and green channels and 10 bits for the
 * blue channel.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_111110F = 18;
/**
 * Color-only sRGB format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_SRGB8 = 19;
/**
 * Color sRGB format with additional alpha channel.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_SRGBA8 = 20;
/**
 * ETC1 compressed format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_ETC1 = 21;
/**
 * ETC2 (RGB) compressed format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_ETC2_RGB = 22;
/**
 * ETC2 (RGBA) compressed format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_ETC2_RGBA = 23;
/**
 * PVRTC (2BPP RGB) compressed format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_PVRTC_2BPP_RGB_1 = 24;
/**
 * PVRTC (2BPP RGBA) compressed format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_PVRTC_2BPP_RGBA_1 = 25;
/**
 * PVRTC (4BPP RGB) compressed format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_PVRTC_4BPP_RGB_1 = 26;
/**
 * PVRTC (4BPP RGBA) compressed format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_PVRTC_4BPP_RGBA_1 = 27;
/**
 * ATC compressed format with alpha channel in blocks of 4x4.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_ASTC_4x4 = 28;
/**
 * ATC compressed format with no alpha channel.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_ATC_RGB = 29;
/**
 * ATC compressed format with alpha channel.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_ATC_RGBA = 30;
/**
 * 32-bit BGRA (8-bits for blue channel, 8 for green, 8 for red with 8-bit alpha). This is an
 * internal format used by the WebGPU's backbuffer only.
 *
 * @type {number}
 * @ignore
 * @category Graphics
 */ var PIXELFORMAT_BGRA8 = 31;
/**
 * 8-bit signed integer single-channel (R) format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_R8I = 32;
/**
 * 8-bit unsigned integer single-channel (R) format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_R8U = 33;
/**
 * 16-bit signed integer single-channel (R) format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_R16I = 34;
/**
 * 16-bit unsigned integer single-channel (R) format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_R16U = 35;
/**
 * 32-bit signed integer single-channel (R) format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_R32I = 36;
/**
 * 32-bit unsigned integer single-channel (R) format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_R32U = 37;
/**
 * 8-bit per-channel signed integer (RG) format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_RG8I = 38;
/**
 * 8-bit per-channel unsigned integer (RG) format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_RG8U = 39;
/**
 * 16-bit per-channel signed integer (RG) format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_RG16I = 40;
/**
 * 16-bit per-channel unsigned integer (RG) format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_RG16U = 41;
/**
 * 32-bit per-channel signed integer (RG) format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_RG32I = 42;
/**
 * 32-bit per-channel unsigned integer (RG) format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_RG32U = 43;
/**
 * 8-bit per-channel signed integer (RGBA) format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_RGBA8I = 44;
/**
 * 8-bit per-channel unsigned integer (RGBA) format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_RGBA8U = 45;
/**
 * 16-bit per-channel signed integer (RGBA) format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_RGBA16I = 46;
/**
 * 16-bit per-channel unsigned integer (RGBA) format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_RGBA16U = 47;
/**
 * 32-bit per-channel signed integer (RGBA) format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_RGBA32I = 48;
/**
 * 32-bit per-channel unsigned integer (RGBA) format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_RGBA32U = 49;
/**
 * 16-bit floating point R (16-bit float for red channel).
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_R16F = 50;
/**
 * 16-bit floating point RG (16-bit float for each red and green channels).
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_RG16F = 51;
/**
 * 8-bit per-channel (R) format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_R8 = 52;
/**
 * 8-bit per-channel (RG) format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_RG8 = 53;
/**
 * Format equivalent to {@link PIXELFORMAT_DXT1} but sampled in linear color space.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_DXT1_SRGB = 54;
/**
 * Format equivalent to {@link PIXELFORMAT_DXT3} but sampled in linear color space.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_DXT3_SRGBA = 55;
/**
 * Format equivalent to {@link PIXELFORMAT_DXT5} but sampled in linear color space.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_DXT5_SRGBA = 56;
/**
 * Format equivalent to {@link PIXELFORMAT_ETC2_RGB} but sampled in linear color space.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_ETC2_SRGB = 61;
/**
 * Format equivalent to {@link PIXELFORMAT_ETC2_RGBA} but sampled in linear color space.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_ETC2_SRGBA = 62;
/**
 * Format equivalent to {@link PIXELFORMAT_ASTC_4x4} but sampled in linear color space.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_ASTC_4x4_SRGB = 63;
/**
 * 32-bit BGRA sRGB format. This is an internal format used by the WebGPU's backbuffer only.
 *
 * @type {number}
 * @ignore
 * @category Graphics
 */ var PIXELFORMAT_SBGRA8 = 64;
/**
 * Compressed high dynamic range signed floating point format storing RGB values.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_BC6F = 65;
/**
 * Compressed high dynamic range unsigned floating point format storing RGB values.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_BC6UF = 66;
/**
 * Compressed 8-bit fixed-point data. Each 4x4 block of texels consists of 128 bits of RGBA data.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_BC7 = 67;
/**
 * Compressed 8-bit fixed-point data. Each 4x4 block of texels consists of 128 bits of SRGB_ALPHA
 * data.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_BC7_SRGBA = 68;
/**
 * A 16-bit depth buffer format.
 *
 * @type {number}
 * @category Graphics
 */ var PIXELFORMAT_DEPTH16 = 69;
/**
 * Information about pixel formats.
 *
 * ldr: whether the format is low dynamic range (LDR), which typically means it's not HDR, and uses
 * sRGB color space to store the color values
 * srgbFormat: the corresponding sRGB format (which automatically converts the sRGB value to linear)
 *
 * @type {Map<number, { name: string, size?: number, blockSize?: number, ldr?: boolean, srgb?: boolean, srgbFormat?: number, isInt?: boolean }>}
 * @ignore
 */ var pixelFormatInfo = new Map([
    // float formats
    [
        PIXELFORMAT_A8,
        {
            name: 'A8',
            size: 1,
            ldr: true
        }
    ],
    [
        PIXELFORMAT_R8,
        {
            name: 'R8',
            size: 1,
            ldr: true
        }
    ],
    [
        PIXELFORMAT_L8,
        {
            name: 'L8',
            size: 1,
            ldr: true
        }
    ],
    [
        PIXELFORMAT_LA8,
        {
            name: 'LA8',
            size: 2,
            ldr: true
        }
    ],
    [
        PIXELFORMAT_RG8,
        {
            name: 'RG8',
            size: 2,
            ldr: true
        }
    ],
    [
        PIXELFORMAT_RGB565,
        {
            name: 'RGB565',
            size: 2,
            ldr: true
        }
    ],
    [
        PIXELFORMAT_RGBA5551,
        {
            name: 'RGBA5551',
            size: 2,
            ldr: true
        }
    ],
    [
        PIXELFORMAT_RGBA4,
        {
            name: 'RGBA4',
            size: 2,
            ldr: true
        }
    ],
    [
        PIXELFORMAT_RGB8,
        {
            name: 'RGB8',
            size: 4,
            ldr: true
        }
    ],
    [
        PIXELFORMAT_RGBA8,
        {
            name: 'RGBA8',
            size: 4,
            ldr: true,
            srgbFormat: PIXELFORMAT_SRGBA8
        }
    ],
    [
        PIXELFORMAT_R16F,
        {
            name: 'R16F',
            size: 2
        }
    ],
    [
        PIXELFORMAT_RG16F,
        {
            name: 'RG16F',
            size: 4
        }
    ],
    [
        PIXELFORMAT_RGB16F,
        {
            name: 'RGB16F',
            size: 8
        }
    ],
    [
        PIXELFORMAT_RGBA16F,
        {
            name: 'RGBA16F',
            size: 8
        }
    ],
    [
        PIXELFORMAT_RGB32F,
        {
            name: 'RGB32F',
            size: 16
        }
    ],
    [
        PIXELFORMAT_RGBA32F,
        {
            name: 'RGBA32F',
            size: 16
        }
    ],
    [
        PIXELFORMAT_R32F,
        {
            name: 'R32F',
            size: 4
        }
    ],
    [
        PIXELFORMAT_DEPTH,
        {
            name: 'DEPTH',
            size: 4
        }
    ],
    [
        PIXELFORMAT_DEPTH16,
        {
            name: 'DEPTH16',
            size: 2
        }
    ],
    [
        PIXELFORMAT_DEPTHSTENCIL,
        {
            name: 'DEPTHSTENCIL',
            size: 4
        }
    ],
    [
        PIXELFORMAT_111110F,
        {
            name: '111110F',
            size: 4
        }
    ],
    [
        PIXELFORMAT_SRGB8,
        {
            name: 'SRGB8',
            size: 4,
            ldr: true,
            srgb: true
        }
    ],
    [
        PIXELFORMAT_SRGBA8,
        {
            name: 'SRGBA8',
            size: 4,
            ldr: true,
            srgb: true
        }
    ],
    [
        PIXELFORMAT_BGRA8,
        {
            name: 'BGRA8',
            size: 4,
            ldr: true
        }
    ],
    [
        PIXELFORMAT_SBGRA8,
        {
            name: 'SBGRA8',
            size: 4,
            ldr: true,
            srgb: true
        }
    ],
    // compressed formats
    [
        PIXELFORMAT_DXT1,
        {
            name: 'DXT1',
            blockSize: 8,
            ldr: true,
            srgbFormat: PIXELFORMAT_DXT1_SRGB
        }
    ],
    [
        PIXELFORMAT_DXT3,
        {
            name: 'DXT3',
            blockSize: 16,
            ldr: true,
            srgbFormat: PIXELFORMAT_DXT3_SRGBA
        }
    ],
    [
        PIXELFORMAT_DXT5,
        {
            name: 'DXT5',
            blockSize: 16,
            ldr: true,
            srgbFormat: PIXELFORMAT_DXT5_SRGBA
        }
    ],
    [
        PIXELFORMAT_ETC1,
        {
            name: 'ETC1',
            blockSize: 8,
            ldr: true
        }
    ],
    [
        PIXELFORMAT_ETC2_RGB,
        {
            name: 'ETC2_RGB',
            blockSize: 8,
            ldr: true,
            srgbFormat: PIXELFORMAT_ETC2_SRGB
        }
    ],
    [
        PIXELFORMAT_ETC2_RGBA,
        {
            name: 'ETC2_RGBA',
            blockSize: 16,
            ldr: true,
            srgbFormat: PIXELFORMAT_ETC2_SRGBA
        }
    ],
    [
        PIXELFORMAT_PVRTC_2BPP_RGB_1,
        {
            name: 'PVRTC_2BPP_RGB_1',
            ldr: true,
            blockSize: 8
        }
    ],
    [
        PIXELFORMAT_PVRTC_2BPP_RGBA_1,
        {
            name: 'PVRTC_2BPP_RGBA_1',
            ldr: true,
            blockSize: 8
        }
    ],
    [
        PIXELFORMAT_PVRTC_4BPP_RGB_1,
        {
            name: 'PVRTC_4BPP_RGB_1',
            ldr: true,
            blockSize: 8
        }
    ],
    [
        PIXELFORMAT_PVRTC_4BPP_RGBA_1,
        {
            name: 'PVRTC_4BPP_RGBA_1',
            ldr: true,
            blockSize: 8
        }
    ],
    [
        PIXELFORMAT_ASTC_4x4,
        {
            name: 'ASTC_4x4',
            blockSize: 16,
            ldr: true,
            srgbFormat: PIXELFORMAT_ASTC_4x4_SRGB
        }
    ],
    [
        PIXELFORMAT_ATC_RGB,
        {
            name: 'ATC_RGB',
            blockSize: 8,
            ldr: true
        }
    ],
    [
        PIXELFORMAT_ATC_RGBA,
        {
            name: 'ATC_RGBA',
            blockSize: 16,
            ldr: true
        }
    ],
    [
        PIXELFORMAT_BC6F,
        {
            name: 'BC6H_RGBF',
            blockSize: 16
        }
    ],
    [
        PIXELFORMAT_BC6UF,
        {
            name: 'BC6H_RGBUF',
            blockSize: 16
        }
    ],
    [
        PIXELFORMAT_BC7,
        {
            name: 'BC7_RGBA',
            blockSize: 16,
            ldr: true,
            srgbFormat: PIXELFORMAT_BC7_SRGBA
        }
    ],
    // compressed sRGB formats
    [
        PIXELFORMAT_DXT1_SRGB,
        {
            name: 'DXT1_SRGB',
            blockSize: 8,
            ldr: true,
            srgb: true
        }
    ],
    [
        PIXELFORMAT_DXT3_SRGBA,
        {
            name: 'DXT3_SRGBA',
            blockSize: 16,
            ldr: true,
            srgb: true
        }
    ],
    [
        PIXELFORMAT_DXT5_SRGBA,
        {
            name: 'DXT5_SRGBA',
            blockSize: 16,
            ldr: true,
            srgb: true
        }
    ],
    [
        PIXELFORMAT_ETC2_SRGB,
        {
            name: 'ETC2_SRGB',
            blockSize: 8,
            ldr: true,
            srgb: true
        }
    ],
    [
        PIXELFORMAT_ETC2_SRGBA,
        {
            name: 'ETC2_SRGBA',
            blockSize: 16,
            ldr: true,
            srgb: true
        }
    ],
    [
        PIXELFORMAT_ASTC_4x4_SRGB,
        {
            name: 'ASTC_4x4_SRGB',
            blockSize: 16,
            ldr: true,
            srgb: true
        }
    ],
    [
        PIXELFORMAT_BC7_SRGBA,
        {
            name: 'BC7_SRGBA',
            blockSize: 16,
            ldr: true,
            srgb: true
        }
    ],
    // integer formats
    [
        PIXELFORMAT_R8I,
        {
            name: 'R8I',
            size: 1,
            isInt: true
        }
    ],
    [
        PIXELFORMAT_R8U,
        {
            name: 'R8U',
            size: 1,
            isInt: true
        }
    ],
    [
        PIXELFORMAT_R16I,
        {
            name: 'R16I',
            size: 2,
            isInt: true
        }
    ],
    [
        PIXELFORMAT_R16U,
        {
            name: 'R16U',
            size: 2,
            isInt: true
        }
    ],
    [
        PIXELFORMAT_R32I,
        {
            name: 'R32I',
            size: 4,
            isInt: true
        }
    ],
    [
        PIXELFORMAT_R32U,
        {
            name: 'R32U',
            size: 4,
            isInt: true
        }
    ],
    [
        PIXELFORMAT_RG8I,
        {
            name: 'RG8I',
            size: 2,
            isInt: true
        }
    ],
    [
        PIXELFORMAT_RG8U,
        {
            name: 'RG8U',
            size: 2,
            isInt: true
        }
    ],
    [
        PIXELFORMAT_RG16I,
        {
            name: 'RG16I',
            size: 4,
            isInt: true
        }
    ],
    [
        PIXELFORMAT_RG16U,
        {
            name: 'RG16U',
            size: 4,
            isInt: true
        }
    ],
    [
        PIXELFORMAT_RG32I,
        {
            name: 'RG32I',
            size: 8,
            isInt: true
        }
    ],
    [
        PIXELFORMAT_RG32U,
        {
            name: 'RG32U',
            size: 8,
            isInt: true
        }
    ],
    [
        PIXELFORMAT_RGBA8I,
        {
            name: 'RGBA8I',
            size: 4,
            isInt: true
        }
    ],
    [
        PIXELFORMAT_RGBA8U,
        {
            name: 'RGBA8U',
            size: 4,
            isInt: true
        }
    ],
    [
        PIXELFORMAT_RGBA16I,
        {
            name: 'RGBA16I',
            size: 8,
            isInt: true
        }
    ],
    [
        PIXELFORMAT_RGBA16U,
        {
            name: 'RGBA16U',
            size: 8,
            isInt: true
        }
    ],
    [
        PIXELFORMAT_RGBA32I,
        {
            name: 'RGBA32I',
            size: 16,
            isInt: true
        }
    ],
    [
        PIXELFORMAT_RGBA32U,
        {
            name: 'RGBA32U',
            size: 16,
            isInt: true
        }
    ]
]);
// update this function when exposing additional compressed pixel formats
var isCompressedPixelFormat = (format)=>{
    var _pixelFormatInfo_get;
    return ((_pixelFormatInfo_get = pixelFormatInfo.get(format)) == null ? undefined : _pixelFormatInfo_get.blockSize) !== undefined;
};
var isSrgbPixelFormat = (format)=>{
    var _pixelFormatInfo_get;
    return ((_pixelFormatInfo_get = pixelFormatInfo.get(format)) == null ? undefined : _pixelFormatInfo_get.srgb) === true;
};
var isIntegerPixelFormat = (format)=>{
    var _pixelFormatInfo_get;
    return ((_pixelFormatInfo_get = pixelFormatInfo.get(format)) == null ? undefined : _pixelFormatInfo_get.isInt) === true;
};
/**
 * Returns the srgb equivalent format for the supplied linear format. If it does not exist, the input
 * format is returned. For example for {@link PIXELFORMAT_RGBA8} the return value is
 * {@link PIXELFORMAT_SRGBA8}.
 *
 * @param {number} format - The texture format.
 * @returns {number} The format allowing linear sampling of the texture.
 * @ignore
 */ var pixelFormatLinearToGamma = (format)=>{
    var _pixelFormatInfo_get;
    return ((_pixelFormatInfo_get = pixelFormatInfo.get(format)) == null ? undefined : _pixelFormatInfo_get.srgbFormat) || format;
};
/**
 * Returns the linear equivalent format for the supplied sRGB format. If it does not exist, the input
 * format is returned. For example for {@link PIXELFORMAT_SRGBA8} the return value is
 * {@link PIXELFORMAT_RGBA8}.
 *
 * @param {number} format - The texture format.
 * @returns {number} The equivalent format without automatic sRGB conversion.
 * @ignore
 */ var pixelFormatGammaToLinear = (format)=>{
    for (var [key, value] of pixelFormatInfo){
        if (value.srgbFormat === format) {
            return key;
        }
    }
    return format;
};
/**
 * For a pixel format that stores color information, this function returns true if the texture
 * sample is in sRGB space and needs to be decoded to linear space.
 *
 * @param {number} format - The texture format.
 * @returns {boolean} Whether sampling the texture with this format returns a sRGB value.
 * @ignore
 */ var requiresManualGamma = (format)=>{
    var info = pixelFormatInfo.get(format);
    return !!((info == null ? undefined : info.ldr) && !(info == null ? undefined : info.srgb));
};
// get the pixel format array type
var getPixelFormatArrayType = (format)=>{
    switch(format){
        case PIXELFORMAT_R32F:
        case PIXELFORMAT_RGB32F:
        case PIXELFORMAT_RGBA32F:
            return Float32Array;
        case PIXELFORMAT_R32I:
        case PIXELFORMAT_RG32I:
        case PIXELFORMAT_RGBA32I:
            return Int32Array;
        case PIXELFORMAT_R32U:
        case PIXELFORMAT_RG32U:
        case PIXELFORMAT_RGBA32U:
            return Uint32Array;
        case PIXELFORMAT_R16I:
        case PIXELFORMAT_RG16I:
        case PIXELFORMAT_RGBA16I:
            return Int16Array;
        case PIXELFORMAT_RG8:
        case PIXELFORMAT_R16U:
        case PIXELFORMAT_RG16U:
        case PIXELFORMAT_RGBA16U:
        case PIXELFORMAT_RGB565:
        case PIXELFORMAT_RGBA5551:
        case PIXELFORMAT_RGBA4:
        case PIXELFORMAT_R16F:
        case PIXELFORMAT_RG16F:
        case PIXELFORMAT_RGB16F:
        case PIXELFORMAT_RGBA16F:
            return Uint16Array;
        case PIXELFORMAT_R8I:
        case PIXELFORMAT_RG8I:
        case PIXELFORMAT_RGBA8I:
            return Int8Array;
        default:
            return Uint8Array;
    }
};
/**
 * List of distinct points.
 *
 * @type {number}
 * @category Graphics
 */ var PRIMITIVE_POINTS = 0;
/**
 * Discrete list of line segments.
 *
 * @type {number}
 * @category Graphics
 */ var PRIMITIVE_LINES = 1;
/**
 * List of points that are linked sequentially by line segments, with a closing line segment
 * between the last and first points.
 *
 * @type {number}
 * @category Graphics
 */ var PRIMITIVE_LINELOOP = 2;
/**
 * List of points that are linked sequentially by line segments.
 *
 * @type {number}
 * @category Graphics
 */ var PRIMITIVE_LINESTRIP = 3;
/**
 * Discrete list of triangles.
 *
 * @type {number}
 * @category Graphics
 */ var PRIMITIVE_TRIANGLES = 4;
/**
 * Connected strip of triangles where a specified vertex forms a triangle using the previous two.
 *
 * @type {number}
 * @category Graphics
 */ var PRIMITIVE_TRISTRIP = 5;
/**
 * Connected fan of triangles where the first vertex forms triangles with the following pairs of vertices.
 *
 * @type {number}
 * @category Graphics
 */ var PRIMITIVE_TRIFAN = 6;
/**
 * Vertex attribute to be treated as a position.
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_POSITION = 'POSITION';
/**
 * Vertex attribute to be treated as a normal.
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_NORMAL = 'NORMAL';
/**
 * Vertex attribute to be treated as a tangent.
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_TANGENT = 'TANGENT';
/**
 * Vertex attribute to be treated as skin blend weights.
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_BLENDWEIGHT = 'BLENDWEIGHT';
/**
 * Vertex attribute to be treated as skin blend indices.
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_BLENDINDICES = 'BLENDINDICES';
/**
 * Vertex attribute to be treated as a color.
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_COLOR = 'COLOR';
// private semantic used for programmatic construction of individual texcoord semantics
var SEMANTIC_TEXCOORD = 'TEXCOORD';
/**
 * Vertex attribute to be treated as a texture coordinate (set 0).
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_TEXCOORD0 = 'TEXCOORD0';
/**
 * Vertex attribute to be treated as a texture coordinate (set 1).
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_TEXCOORD1 = 'TEXCOORD1';
/**
 * Vertex attribute to be treated as a texture coordinate (set 2).
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_TEXCOORD2 = 'TEXCOORD2';
/**
 * Vertex attribute to be treated as a texture coordinate (set 3).
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_TEXCOORD3 = 'TEXCOORD3';
/**
 * Vertex attribute to be treated as a texture coordinate (set 4).
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_TEXCOORD4 = 'TEXCOORD4';
/**
 * Vertex attribute to be treated as a texture coordinate (set 5).
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_TEXCOORD5 = 'TEXCOORD5';
/**
 * Vertex attribute to be treated as a texture coordinate (set 6).
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_TEXCOORD6 = 'TEXCOORD6';
/**
 * Vertex attribute to be treated as a texture coordinate (set 7).
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_TEXCOORD7 = 'TEXCOORD7';
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_ATTR0 = 'ATTR0';
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_ATTR1 = 'ATTR1';
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_ATTR2 = 'ATTR2';
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_ATTR3 = 'ATTR3';
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_ATTR4 = 'ATTR4';
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_ATTR5 = 'ATTR5';
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_ATTR6 = 'ATTR6';
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_ATTR7 = 'ATTR7';
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_ATTR8 = 'ATTR8';
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_ATTR9 = 'ATTR9';
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_ATTR10 = 'ATTR10';
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_ATTR11 = 'ATTR11';
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_ATTR12 = 'ATTR12';
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_ATTR13 = 'ATTR13';
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_ATTR14 = 'ATTR14';
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 * @category Graphics
 */ var SEMANTIC_ATTR15 = 'ATTR15';
var SHADERTAG_MATERIAL = 1;
/**
 * Don't change the stencil buffer value.
 *
 * @type {number}
 * @category Graphics
 */ var STENCILOP_KEEP = 0;
/**
 * Set value to zero.
 *
 * @type {number}
 * @category Graphics
 */ var STENCILOP_ZERO = 1;
/**
 * Replace value with the reference value (see {@link StencilParameters}).
 *
 * @type {number}
 * @category Graphics
 */ var STENCILOP_REPLACE = 2;
/**
 * Increment the value.
 *
 * @type {number}
 * @category Graphics
 */ var STENCILOP_INCREMENT = 3;
/**
 * Increment the value but wrap it to zero when it's larger than a maximum representable value.
 *
 * @type {number}
 * @category Graphics
 */ var STENCILOP_INCREMENTWRAP = 4;
/**
 * Decrement the value.
 *
 * @type {number}
 * @category Graphics
 */ var STENCILOP_DECREMENT = 5;
/**
 * Decrement the value but wrap it to a maximum representable value if the current value is 0.
 *
 * @type {number}
 * @category Graphics
 */ var STENCILOP_DECREMENTWRAP = 6;
/**
 * Invert the value bitwise.
 *
 * @type {number}
 * @category Graphics
 */ var STENCILOP_INVERT = 7;
/**
 * The texture is not in a locked state.
 *
 * @type {number}
 */ var TEXTURELOCK_NONE = 0;
/**
 * Read only. Any changes to the locked mip level's pixels will not update the texture.
 *
 * @type {number}
 * @category Graphics
 */ var TEXTURELOCK_READ = 1;
/**
 * Write only. The contents of the specified mip level will be entirely replaced.
 *
 * @type {number}
 * @category Graphics
 */ var TEXTURELOCK_WRITE = 2;
/**
 * Texture is a default type.
 *
 * @type {string}
 * @category Graphics
 */ var TEXTURETYPE_DEFAULT = 'default';
/**
 * Texture stores high dynamic range data in RGBM format.
 *
 * @type {string}
 * @category Graphics
 */ var TEXTURETYPE_RGBM = 'rgbm';
/**
 * Texture stores high dynamic range data in RGBE format.
 *
 * @type {string}
 * @category Graphics
 */ var TEXTURETYPE_RGBE = 'rgbe';
/**
 * Texture stores high dynamic range data in RGBP encoding.
 *
 * @type {string}
 * @category Graphics
 */ var TEXTURETYPE_RGBP = 'rgbp';
/**
 * Texture stores normalmap data swizzled in GGGR format. This is used for tangent space normal
 * maps. The R component is stored in alpha and G is stored in RGB. This packing can result in
 * higher quality when the texture data is compressed.
 *
 * @type {string}
 * @category Graphics
 */ var TEXTURETYPE_SWIZZLEGGGR = 'swizzleGGGR';
var TEXHINT_NONE = 0;
var TEXHINT_SHADOWMAP = 1;
var TEXHINT_ASSET = 2;
var TEXHINT_LIGHTMAP = 3;
/**
 * Texture data is stored in a 1-dimensional texture.
 *
 * @type {string}
 * @category Graphics
 */ var TEXTUREDIMENSION_1D = '1d';
/**
 * Texture data is stored in a 2-dimensional texture.
 *
 * @type {string}
 * @category Graphics
 */ var TEXTUREDIMENSION_2D = '2d';
/**
 * Texture data is stored in an array of 2-dimensional textures.
 *
 * @type {string}
 * @category Graphics
 */ var TEXTUREDIMENSION_2D_ARRAY = '2d-array';
/**
 * Texture data is stored in a cube texture.
 *
 * @type {string}
 * @category Graphics
 */ var TEXTUREDIMENSION_CUBE = 'cube';
/**
 * Texture data is stored in an array of cube textures.
 *
 * @type {string}
 * @category Graphics
 */ var TEXTUREDIMENSION_CUBE_ARRAY = 'cube-array';
/**
 * Texture data is stored in a 3-dimensional texture.
 *
 * @type {string}
 * @category Graphics
 */ var TEXTUREDIMENSION_3D = '3d';
/**
 * A sampler type of a texture that contains floating-point data. Typically stored for color
 * textures, where data can be filtered.
 *
 * @type {number}
 * @category Graphics
 */ var SAMPLETYPE_FLOAT = 0;
/**
 * A sampler type of a texture that contains floating-point data, but cannot be filtered. Typically
 * used for textures storing data that cannot be interpolated.
 *
 * @type {number}
 * @category Graphics
 */ var SAMPLETYPE_UNFILTERABLE_FLOAT = 1;
/**
 * A sampler type of a texture that contains depth data. Typically used for depth textures.
 *
 * @type {number}
 * @category Graphics
 */ var SAMPLETYPE_DEPTH = 2;
/**
 * A sampler type of a texture that contains signed integer data.
 *
 * @type {number}
 * @category Graphics
 */ var SAMPLETYPE_INT = 3;
/**
 * A sampler type of a texture that contains unsigned integer data.
 *
 * @type {number}
 * @category Graphics
 */ var SAMPLETYPE_UINT = 4;
/**
 * Texture data is not stored a specific projection format.
 *
 * @type {string}
 * @category Graphics
 */ var TEXTUREPROJECTION_NONE = 'none';
/**
 * Texture data is stored in cubemap projection format.
 *
 * @type {string}
 * @category Graphics
 */ var TEXTUREPROJECTION_CUBE = 'cube';
/**
 * Texture data is stored in equirectangular projection format.
 *
 * @type {string}
 * @category Graphics
 */ var TEXTUREPROJECTION_EQUIRECT = 'equirect';
/**
 * Texture data is stored in octahedral projection format.
 *
 * @type {string}
 * @category Graphics
 */ var TEXTUREPROJECTION_OCTAHEDRAL = 'octahedral';
/**
 * Shader source code uses GLSL language.
 *
 * @type {string}
 * @category Graphics
 */ var SHADERLANGUAGE_GLSL = 'glsl';
/**
 * Shader source code uses WGSL language.
 *
 * @type {string}
 * @category Graphics
 */ var SHADERLANGUAGE_WGSL = 'wgsl';
/**
 * Signed byte vertex element type.
 *
 * @type {number}
 * @category Graphics
 */ var TYPE_INT8 = 0;
/**
 * Unsigned byte vertex element type.
 *
 * @type {number}
 * @category Graphics
 */ var TYPE_UINT8 = 1;
/**
 * Signed short vertex element type.
 *
 * @type {number}
 * @category Graphics
 */ var TYPE_INT16 = 2;
/**
 * Unsigned short vertex element type.
 *
 * @type {number}
 * @category Graphics
 */ var TYPE_UINT16 = 3;
/**
 * Signed integer vertex element type.
 *
 * @type {number}
 * @category Graphics
 */ var TYPE_INT32 = 4;
/**
 * Unsigned integer vertex element type.
 *
 * @type {number}
 * @category Graphics
 */ var TYPE_UINT32 = 5;
/**
 * Floating point vertex element type.
 *
 * @type {number}
 * @category Graphics
 */ var TYPE_FLOAT32 = 6;
/**
 * 16-bit floating point vertex element type.
 *
 * @type {number}
 * @category Graphics
 */ var TYPE_FLOAT16 = 7;
// ---------- Uniform types ------------
// Note: Only types which can be used in uniform buffers are exported here, others are internal.
// The arrays are exposed as a base type with number of elements, and textures are not part of the
// uniform buffers.
/**
 * Boolean uniform type.
 *
 * @type {number}
 * @category Graphics
 */ var UNIFORMTYPE_BOOL = 0;
/**
 * Integer uniform type.
 *
 * @type {number}
 * @category Graphics
 */ var UNIFORMTYPE_INT = 1;
/**
 * Float uniform type.
 *
 * @type {number}
 * @category Graphics
 */ var UNIFORMTYPE_FLOAT = 2;
/**
 * 2 x Float uniform type.
 *
 * @type {number}
 * @category Graphics
 */ var UNIFORMTYPE_VEC2 = 3;
/**
 * 3 x Float uniform type.
 *
 * @type {number}
 * @category Graphics
 */ var UNIFORMTYPE_VEC3 = 4;
/**
 * 4 x Float uniform type.
 *
 * @type {number}
 * @category Graphics
 */ var UNIFORMTYPE_VEC4 = 5;
/**
 * 2 x Integer uniform type.
 *
 * @type {number}
 * @category Graphics
 */ var UNIFORMTYPE_IVEC2 = 6;
/**
 * 3 x Integer uniform type.
 *
 * @type {number}
 * @category Graphics
 */ var UNIFORMTYPE_IVEC3 = 7;
/**
 * 4 x Integer uniform type.
 *
 * @type {number}
 * @category Graphics
 */ var UNIFORMTYPE_IVEC4 = 8;
/**
 * 2 x Boolean uniform type.
 *
 * @type {number}
 * @category Graphics
 */ var UNIFORMTYPE_BVEC2 = 9;
/**
 * 3 x Boolean uniform type.
 *
 * @type {number}
 * @category Graphics
 */ var UNIFORMTYPE_BVEC3 = 10;
/**
 * 4 x Boolean uniform type.
 *
 * @type {number}
 * @category Graphics
 */ var UNIFORMTYPE_BVEC4 = 11;
/**
 * 2 x 2 x Float uniform type.
 *
 * @type {number}
 * @category Graphics
 */ var UNIFORMTYPE_MAT2 = 12;
/**
 * 3 x 3 x Float uniform type.
 *
 * @type {number}
 * @category Graphics
 */ var UNIFORMTYPE_MAT3 = 13;
/**
 * 4 x 4 x Float uniform type.
 *
 * @type {number}
 * @category Graphics
 */ var UNIFORMTYPE_MAT4 = 14;
var UNIFORMTYPE_TEXTURE2D = 15;
var UNIFORMTYPE_TEXTURECUBE = 16;
var UNIFORMTYPE_FLOATARRAY = 17;
var UNIFORMTYPE_TEXTURE2D_SHADOW = 18;
var UNIFORMTYPE_TEXTURECUBE_SHADOW = 19;
var UNIFORMTYPE_TEXTURE3D = 20;
var UNIFORMTYPE_VEC2ARRAY = 21;
var UNIFORMTYPE_VEC3ARRAY = 22;
var UNIFORMTYPE_VEC4ARRAY = 23;
var UNIFORMTYPE_MAT4ARRAY = 24;
var UNIFORMTYPE_TEXTURE2D_ARRAY = 25;
// Unsigned uniform types
/**
 * Unsigned integer uniform type.
 *
 * @type {number}
 * @category Graphics
 */ var UNIFORMTYPE_UINT = 26;
/**
 * 2 x Unsigned integer uniform type.
 *
 * @type {number}
 * @category Graphics
 */ var UNIFORMTYPE_UVEC2 = 27;
/**
 * 3 x Unsigned integer uniform type.
 *
 * @type {number}
 * @category Graphics
 */ var UNIFORMTYPE_UVEC3 = 28;
/**
 * 4 x Unsigned integer uniform type.
 *
 * @type {number}
 * @category Graphics
 */ var UNIFORMTYPE_UVEC4 = 29;
// Integer uniform array types
var UNIFORMTYPE_INTARRAY = 30;
var UNIFORMTYPE_UINTARRAY = 31;
var UNIFORMTYPE_BOOLARRAY = 32;
var UNIFORMTYPE_IVEC2ARRAY = 33;
var UNIFORMTYPE_UVEC2ARRAY = 34;
var UNIFORMTYPE_BVEC2ARRAY = 35;
var UNIFORMTYPE_IVEC3ARRAY = 36;
var UNIFORMTYPE_UVEC3ARRAY = 37;
var UNIFORMTYPE_BVEC3ARRAY = 38;
var UNIFORMTYPE_IVEC4ARRAY = 39;
var UNIFORMTYPE_UVEC4ARRAY = 40;
var UNIFORMTYPE_BVEC4ARRAY = 41;
// Integer texture types
var UNIFORMTYPE_ITEXTURE2D = 42;
var UNIFORMTYPE_UTEXTURE2D = 43;
var UNIFORMTYPE_ITEXTURECUBE = 44;
var UNIFORMTYPE_UTEXTURECUBE = 45;
var UNIFORMTYPE_ITEXTURE3D = 46;
var UNIFORMTYPE_UTEXTURE3D = 47;
var UNIFORMTYPE_ITEXTURE2D_ARRAY = 48;
var UNIFORMTYPE_UTEXTURE2D_ARRAY = 49;
// ----------
// Uniform types in GLSL
var uniformTypeToName = [
    // Uniforms
    'bool',
    'int',
    'float',
    'vec2',
    'vec3',
    'vec4',
    'ivec2',
    'ivec3',
    'ivec4',
    'bvec2',
    'bvec3',
    'bvec4',
    'mat2',
    'mat3',
    'mat4',
    'sampler2D',
    'samplerCube',
    '',
    'sampler2DShadow',
    'samplerCubeShadow',
    'sampler3D',
    '',
    '',
    '',
    '',
    'sampler2DArray',
    'uint',
    'uvec2',
    'uvec3',
    'uvec4',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    'isampler2D',
    'usampler2D',
    'isamplerCube',
    'usamplerCube',
    'isampler3D',
    'usampler3D',
    'isampler2DArray',
    'usampler2DArray'
];
// Uniform types in WGSL
var uniformTypeToNameWGSL = [
    // Uniforms
    [
        'bool'
    ],
    [
        'i32'
    ],
    [
        'f32'
    ],
    [
        'vec2f',
        'vec2<f32>'
    ],
    [
        'vec3f',
        'vec3<f32>'
    ],
    [
        'vec4f',
        'vec4<f32>'
    ],
    [
        'vec2i',
        'vec2<i32>'
    ],
    [
        'vec3i',
        'vec3<i32>'
    ],
    [
        'vec4i',
        'vec4<i32>'
    ],
    [
        'vec2<bool>'
    ],
    [
        'vec3<bool>'
    ],
    [
        'vec4<bool>'
    ],
    [
        'mat2x2f',
        'mat2x2<f32>'
    ],
    [
        'mat3x3f',
        'mat3x3<f32>'
    ],
    [
        'mat4x4f',
        'mat4x4<f32>'
    ],
    [
        'texture_2d<f32>'
    ],
    [
        'texture_cube<f32>'
    ],
    [
        'array<f32>'
    ],
    [
        'texture_depth_2d'
    ],
    [
        'texture_depth_cube'
    ],
    [
        'texture_3d<f32>'
    ],
    [
        'array<vec2<f32>>'
    ],
    [
        'array<vec3<f32>>'
    ],
    [
        'array<vec4<f32>>'
    ],
    [
        'array<mat4x4<f32>>'
    ],
    [
        'texture_2d_array<f32>'
    ],
    // Unsigned integer uniforms
    [
        'u32'
    ],
    [
        'vec2u',
        'vec2<u32>'
    ],
    [
        'vec3u',
        'vec3<u32>'
    ],
    [
        'vec4u',
        'vec4<u32>'
    ],
    // Integer array uniforms
    [
        'array<i32>'
    ],
    [
        'array<u32>'
    ],
    [
        'array<bool>'
    ],
    [
        'array<vec2i>',
        'array<vec2<i32>>'
    ],
    [
        'array<vec2u>',
        'array<vec2<u32>>'
    ],
    [
        'array<vec2b>',
        'array<vec2<bool>>'
    ],
    [
        'array<vec3i>',
        'array<vec3<i32>>'
    ],
    [
        'array<vec3u>',
        'array<vec3<u32>>'
    ],
    [
        'array<vec3b>',
        'array<vec3<bool>>'
    ],
    [
        'array<vec4i>',
        'array<vec4<i32>>'
    ],
    [
        'array<vec4u>',
        'array<vec4<u32>>'
    ],
    [
        'array<vec4b>',
        'array<vec4<bool>>'
    ],
    // Integer texture types
    [
        'texture_2d<i32>'
    ],
    [
        'texture_2d<u32>'
    ],
    [
        'texture_cube<i32>'
    ],
    [
        'texture_cube<u32>'
    ],
    [
        'texture_3d<i32>'
    ],
    [
        'texture_3d<u32>'
    ],
    [
        'texture_2d_array<i32>'
    ],
    [
        'texture_2d_array<u32>'
    ] // UNIFORMTYPE_UTEXTURE2D_ARRAY
];
// map version of uniformTypeToNameMapWGSL, allowing type name lookup by type name
var uniformTypeToNameMapWGSL = new Map();
uniformTypeToNameWGSL.forEach((names, index)=>{
    names.forEach((name)=>uniformTypeToNameMapWGSL.set(name, index));
});
// Map to convert uniform type to storage type, used in uniform-buffer.js
var uniformTypeToStorage = new Uint8Array([
    TYPE_INT32,
    TYPE_INT32,
    TYPE_FLOAT32,
    TYPE_FLOAT32,
    TYPE_FLOAT32,
    TYPE_FLOAT32,
    TYPE_INT32,
    TYPE_INT32,
    TYPE_INT32,
    TYPE_INT32,
    TYPE_INT32,
    TYPE_INT32,
    TYPE_FLOAT32,
    TYPE_FLOAT32,
    TYPE_FLOAT32,
    TYPE_INT32,
    TYPE_INT32,
    TYPE_FLOAT32,
    TYPE_INT32,
    TYPE_INT32,
    TYPE_INT32,
    TYPE_FLOAT32,
    TYPE_FLOAT32,
    TYPE_FLOAT32,
    TYPE_FLOAT32,
    TYPE_INT32,
    TYPE_UINT32,
    TYPE_UINT32,
    TYPE_UINT32,
    TYPE_UINT32,
    TYPE_INT32,
    TYPE_UINT32,
    TYPE_INT32,
    TYPE_INT32,
    TYPE_UINT32,
    TYPE_INT32,
    TYPE_INT32,
    TYPE_UINT32,
    TYPE_INT32,
    TYPE_INT32,
    TYPE_UINT32,
    TYPE_INT32,
    TYPE_INT32,
    TYPE_UINT32,
    TYPE_INT32,
    TYPE_UINT32,
    TYPE_INT32,
    TYPE_UINT32,
    TYPE_INT32,
    TYPE_UINT32 // UNIFORMTYPE_UTEXTURE2D_ARRAY
]);
/**
 * A WebGL 2 device type.
 *
 * @type {string}
 * @category Graphics
 */ var DEVICETYPE_WEBGL2 = 'webgl2';
/**
 * A WebGPU device type.
 *
 * @type {string}
 * @category Graphics
 */ var DEVICETYPE_WEBGPU = 'webgpu';
/**
 * A Null device type.
 *
 * @type {string}
 * @category Graphics
 */ var DEVICETYPE_NULL = 'null';
/**
 * The resource is visible to the vertex shader.
 *
 * @type {number}
 * @category Graphics
 */ var SHADERSTAGE_VERTEX = 1;
/**
 * The resource is visible to the fragment shader.
 *
 * @type {number}
 * @category Graphics
 */ var SHADERSTAGE_FRAGMENT = 2;
/**
 * The resource is visible to the compute shader.
 *
 * @type {number}
 * @category Graphics
 */ var SHADERSTAGE_COMPUTE = 4;
/**
 * Display format for low dynamic range data. This is always supported; however, due to the cost, it
 * does not implement linear alpha blending on the main framebuffer. Instead, alpha blending occurs
 * in sRGB space.
 *
 * @type {string}
 * @category Graphics
 */ var DISPLAYFORMAT_LDR = 'ldr';
/**
 * Display format for low dynamic range data in the sRGB color space. This format correctly
 * implements linear alpha blending on the main framebuffer, with the alpha blending occurring in
 * linear space. This is currently supported on WebGPU platform only. On unsupported platforms, it
 * silently falls back to {@link DISPLAYFORMAT_LDR}.
 *
 * @type {string}
 * @category Graphics
 */ var DISPLAYFORMAT_LDR_SRGB = 'ldr_srgb';
/**
 * Display format for high dynamic range data, using 16bit floating point values.
 * Note: This is supported on WebGPU platform only, and ignored on other platforms. On displays
 * without HDR support, it silently falls back to {@link DISPLAYFORMAT_LDR}. Use
 * {@link GraphicsDevice.isHdr} to see if the HDR format is used. When it is, it's recommended to
 * use {@link TONEMAP_NONE} for the tonemapping mode, to avoid it clipping the high dynamic range.
 *
 * @type {string}
 * @category Graphics
 */ var DISPLAYFORMAT_HDR = 'hdr';
// internal flags of the texture properties
var TEXPROPERTY_MIN_FILTER = 1;
var TEXPROPERTY_MAG_FILTER = 2;
var TEXPROPERTY_ADDRESS_U = 4;
var TEXPROPERTY_ADDRESS_V = 8;
var TEXPROPERTY_ADDRESS_W = 16;
var TEXPROPERTY_COMPARE_ON_READ = 32;
var TEXPROPERTY_COMPARE_FUNC = 64;
var TEXPROPERTY_ANISOTROPY = 128;
var TEXPROPERTY_ALL = 255; // 1 | 2 | 4 | 8 | 16 | 32 | 64 | 128
// indices of commonly used bind groups, sorted from the least commonly changing to avoid internal rebinding
var BINDGROUP_VIEW = 0; // view bind group, textures, samplers and uniforms
var BINDGROUP_MESH = 1; // mesh bind group - textures and samplers
var BINDGROUP_MESH_UB = 2; // mesh bind group - a single uniform buffer
// names of bind groups
var bindGroupNames = [
    'view',
    'mesh',
    'mesh_ub'
];
// name of the default uniform buffer slot in a bind group
var UNIFORM_BUFFER_DEFAULT_SLOT_NAME = 'default';
// WebGPU does not support empty uniform buffer, add a dummy uniform to avoid validation errors
var UNUSED_UNIFORM_NAME = '_unused_float_uniform';
// map of engine TYPE_*** enums to their corresponding typed array constructors and byte sizes
var typedArrayTypes = [
    Int8Array,
    Uint8Array,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Uint16Array
];
var typedArrayTypesByteSize = [
    1,
    1,
    2,
    2,
    4,
    4,
    4,
    2
];
var vertexTypesNames = [
    'INT8',
    'UINT8',
    'INT16',
    'UINT16',
    'INT32',
    'UINT32',
    'FLOAT32',
    'FLOAT16'
];
// map of typed array to engine TYPE_***
var typedArrayToType = {
    'Int8Array': TYPE_INT8,
    'Uint8Array': TYPE_UINT8,
    'Int16Array': TYPE_INT16,
    'Uint16Array': TYPE_UINT16,
    'Int32Array': TYPE_INT32,
    'Uint32Array': TYPE_UINT32,
    'Float32Array': TYPE_FLOAT32
};
// map of engine INDEXFORMAT_*** to their corresponding typed array constructors and byte sizes
var typedArrayIndexFormats = [
    Uint8Array,
    Uint16Array,
    Uint32Array
];
var typedArrayIndexFormatsByteSize = [
    1,
    2,
    4
];
/**
 * Map of engine semantics into location on device in range 0..15 (note - semantics mapping to the
 * same location cannot be used at the same time) organized in a way that ATTR0-ATTR7 do not
 * overlap with common important semantics.
 *
 * @type {object}
 * @ignore
 * @category Graphics
 */ var semanticToLocation = {};
semanticToLocation[SEMANTIC_POSITION] = 0;
semanticToLocation[SEMANTIC_NORMAL] = 1;
semanticToLocation[SEMANTIC_BLENDWEIGHT] = 2;
semanticToLocation[SEMANTIC_BLENDINDICES] = 3;
semanticToLocation[SEMANTIC_COLOR] = 4;
semanticToLocation[SEMANTIC_TEXCOORD0] = 5;
semanticToLocation[SEMANTIC_TEXCOORD1] = 6;
semanticToLocation[SEMANTIC_TEXCOORD2] = 7;
semanticToLocation[SEMANTIC_TEXCOORD3] = 8;
semanticToLocation[SEMANTIC_TEXCOORD4] = 9;
semanticToLocation[SEMANTIC_TEXCOORD5] = 10;
semanticToLocation[SEMANTIC_TEXCOORD6] = 11;
semanticToLocation[SEMANTIC_TEXCOORD7] = 12;
semanticToLocation[SEMANTIC_TANGENT] = 13;
semanticToLocation[SEMANTIC_ATTR0] = 0;
semanticToLocation[SEMANTIC_ATTR1] = 1;
semanticToLocation[SEMANTIC_ATTR2] = 2;
semanticToLocation[SEMANTIC_ATTR3] = 3;
semanticToLocation[SEMANTIC_ATTR4] = 4;
semanticToLocation[SEMANTIC_ATTR5] = 5;
semanticToLocation[SEMANTIC_ATTR6] = 6;
semanticToLocation[SEMANTIC_ATTR7] = 7;
semanticToLocation[SEMANTIC_ATTR8] = 8;
semanticToLocation[SEMANTIC_ATTR9] = 9;
semanticToLocation[SEMANTIC_ATTR10] = 10;
semanticToLocation[SEMANTIC_ATTR11] = 11;
semanticToLocation[SEMANTIC_ATTR12] = 12;
semanticToLocation[SEMANTIC_ATTR13] = 13;
semanticToLocation[SEMANTIC_ATTR14] = 14;
semanticToLocation[SEMANTIC_ATTR15] = 15;
/**
 * Chunk API versions
 *
 * @type {string}
 * @category Graphics
 */ var CHUNKAPI_1_51 = '1.51';
var CHUNKAPI_1_55 = '1.55';
var CHUNKAPI_1_56 = '1.56';
var CHUNKAPI_1_57 = '1.57';
var CHUNKAPI_1_58 = '1.58';
var CHUNKAPI_1_60 = '1.60';
var CHUNKAPI_1_62 = '1.62';
var CHUNKAPI_1_65 = '1.65';
var CHUNKAPI_1_70 = '1.70';
var CHUNKAPI_2_1 = '2.1';
var CHUNKAPI_2_3 = '2.3';
var CHUNKAPI_2_5 = '2.5';

export { ADDRESS_CLAMP_TO_EDGE, ADDRESS_MIRRORED_REPEAT, ADDRESS_REPEAT, BINDGROUP_MESH, BINDGROUP_MESH_UB, BINDGROUP_VIEW, BLENDEQUATION_ADD, BLENDEQUATION_MAX, BLENDEQUATION_MIN, BLENDEQUATION_REVERSE_SUBTRACT, BLENDEQUATION_SUBTRACT, BLENDMODE_CONSTANT, BLENDMODE_DST_ALPHA, BLENDMODE_DST_COLOR, BLENDMODE_ONE, BLENDMODE_ONE_MINUS_CONSTANT, BLENDMODE_ONE_MINUS_DST_ALPHA, BLENDMODE_ONE_MINUS_DST_COLOR, BLENDMODE_ONE_MINUS_SRC_ALPHA, BLENDMODE_ONE_MINUS_SRC_COLOR, BLENDMODE_SRC_ALPHA, BLENDMODE_SRC_ALPHA_SATURATE, BLENDMODE_SRC_COLOR, BLENDMODE_ZERO, BUFFERUSAGE_COPY_DST, BUFFERUSAGE_COPY_SRC, BUFFERUSAGE_INDEX, BUFFERUSAGE_INDIRECT, BUFFERUSAGE_READ, BUFFERUSAGE_STORAGE, BUFFERUSAGE_UNIFORM, BUFFERUSAGE_VERTEX, BUFFERUSAGE_WRITE, BUFFER_DYNAMIC, BUFFER_GPUDYNAMIC, BUFFER_STATIC, BUFFER_STREAM, CHUNKAPI_1_51, CHUNKAPI_1_55, CHUNKAPI_1_56, CHUNKAPI_1_57, CHUNKAPI_1_58, CHUNKAPI_1_60, CHUNKAPI_1_62, CHUNKAPI_1_65, CHUNKAPI_1_70, CHUNKAPI_2_1, CHUNKAPI_2_3, CHUNKAPI_2_5, CLEARFLAG_COLOR, CLEARFLAG_DEPTH, CLEARFLAG_STENCIL, CUBEFACE_NEGX, CUBEFACE_NEGY, CUBEFACE_NEGZ, CUBEFACE_POSX, CUBEFACE_POSY, CUBEFACE_POSZ, CULLFACE_BACK, CULLFACE_FRONT, CULLFACE_FRONTANDBACK, CULLFACE_NONE, DEVICETYPE_NULL, DEVICETYPE_WEBGL2, DEVICETYPE_WEBGPU, DISPLAYFORMAT_HDR, DISPLAYFORMAT_LDR, DISPLAYFORMAT_LDR_SRGB, FILTER_LINEAR, FILTER_LINEAR_MIPMAP_LINEAR, FILTER_LINEAR_MIPMAP_NEAREST, FILTER_NEAREST, FILTER_NEAREST_MIPMAP_LINEAR, FILTER_NEAREST_MIPMAP_NEAREST, FUNC_ALWAYS, FUNC_EQUAL, FUNC_GREATER, FUNC_GREATEREQUAL, FUNC_LESS, FUNC_LESSEQUAL, FUNC_NEVER, FUNC_NOTEQUAL, INDEXFORMAT_UINT16, INDEXFORMAT_UINT32, INDEXFORMAT_UINT8, PIXELFORMAT_111110F, PIXELFORMAT_A8, PIXELFORMAT_ASTC_4x4, PIXELFORMAT_ASTC_4x4_SRGB, PIXELFORMAT_ATC_RGB, PIXELFORMAT_ATC_RGBA, PIXELFORMAT_BC6F, PIXELFORMAT_BC6UF, PIXELFORMAT_BC7, PIXELFORMAT_BC7_SRGBA, PIXELFORMAT_BGRA8, PIXELFORMAT_DEPTH, PIXELFORMAT_DEPTH16, PIXELFORMAT_DEPTHSTENCIL, PIXELFORMAT_DXT1, PIXELFORMAT_DXT1_SRGB, PIXELFORMAT_DXT3, PIXELFORMAT_DXT3_SRGBA, PIXELFORMAT_DXT5, PIXELFORMAT_DXT5_SRGBA, PIXELFORMAT_ETC1, PIXELFORMAT_ETC2_RGB, PIXELFORMAT_ETC2_RGBA, PIXELFORMAT_ETC2_SRGB, PIXELFORMAT_ETC2_SRGBA, PIXELFORMAT_L8, PIXELFORMAT_LA8, PIXELFORMAT_PVRTC_2BPP_RGBA_1, PIXELFORMAT_PVRTC_2BPP_RGB_1, PIXELFORMAT_PVRTC_4BPP_RGBA_1, PIXELFORMAT_PVRTC_4BPP_RGB_1, PIXELFORMAT_R16F, PIXELFORMAT_R16I, PIXELFORMAT_R16U, PIXELFORMAT_R32F, PIXELFORMAT_R32I, PIXELFORMAT_R32U, PIXELFORMAT_R8, PIXELFORMAT_R8I, PIXELFORMAT_R8U, PIXELFORMAT_RG16F, PIXELFORMAT_RG16I, PIXELFORMAT_RG16U, PIXELFORMAT_RG32I, PIXELFORMAT_RG32U, PIXELFORMAT_RG8, PIXELFORMAT_RG8I, PIXELFORMAT_RG8U, PIXELFORMAT_RGB16F, PIXELFORMAT_RGB32F, PIXELFORMAT_RGB565, PIXELFORMAT_RGB8, PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA16I, PIXELFORMAT_RGBA16U, PIXELFORMAT_RGBA32F, PIXELFORMAT_RGBA32I, PIXELFORMAT_RGBA32U, PIXELFORMAT_RGBA4, PIXELFORMAT_RGBA5551, PIXELFORMAT_RGBA8, PIXELFORMAT_RGBA8I, PIXELFORMAT_RGBA8U, PIXELFORMAT_SBGRA8, PIXELFORMAT_SRGB8, PIXELFORMAT_SRGBA8, PRIMITIVE_LINELOOP, PRIMITIVE_LINES, PRIMITIVE_LINESTRIP, PRIMITIVE_POINTS, PRIMITIVE_TRIANGLES, PRIMITIVE_TRIFAN, PRIMITIVE_TRISTRIP, SAMPLETYPE_DEPTH, SAMPLETYPE_FLOAT, SAMPLETYPE_INT, SAMPLETYPE_UINT, SAMPLETYPE_UNFILTERABLE_FLOAT, SEMANTIC_ATTR0, SEMANTIC_ATTR1, SEMANTIC_ATTR10, SEMANTIC_ATTR11, SEMANTIC_ATTR12, SEMANTIC_ATTR13, SEMANTIC_ATTR14, SEMANTIC_ATTR15, SEMANTIC_ATTR2, SEMANTIC_ATTR3, SEMANTIC_ATTR4, SEMANTIC_ATTR5, SEMANTIC_ATTR6, SEMANTIC_ATTR7, SEMANTIC_ATTR8, SEMANTIC_ATTR9, SEMANTIC_BLENDINDICES, SEMANTIC_BLENDWEIGHT, SEMANTIC_COLOR, SEMANTIC_NORMAL, SEMANTIC_POSITION, SEMANTIC_TANGENT, SEMANTIC_TEXCOORD, SEMANTIC_TEXCOORD0, SEMANTIC_TEXCOORD1, SEMANTIC_TEXCOORD2, SEMANTIC_TEXCOORD3, SEMANTIC_TEXCOORD4, SEMANTIC_TEXCOORD5, SEMANTIC_TEXCOORD6, SEMANTIC_TEXCOORD7, SHADERLANGUAGE_GLSL, SHADERLANGUAGE_WGSL, SHADERSTAGE_COMPUTE, SHADERSTAGE_FRAGMENT, SHADERSTAGE_VERTEX, SHADERTAG_MATERIAL, STENCILOP_DECREMENT, STENCILOP_DECREMENTWRAP, STENCILOP_INCREMENT, STENCILOP_INCREMENTWRAP, STENCILOP_INVERT, STENCILOP_KEEP, STENCILOP_REPLACE, STENCILOP_ZERO, TEXHINT_ASSET, TEXHINT_LIGHTMAP, TEXHINT_NONE, TEXHINT_SHADOWMAP, TEXPROPERTY_ADDRESS_U, TEXPROPERTY_ADDRESS_V, TEXPROPERTY_ADDRESS_W, TEXPROPERTY_ALL, TEXPROPERTY_ANISOTROPY, TEXPROPERTY_COMPARE_FUNC, TEXPROPERTY_COMPARE_ON_READ, TEXPROPERTY_MAG_FILTER, TEXPROPERTY_MIN_FILTER, TEXTUREDIMENSION_1D, TEXTUREDIMENSION_2D, TEXTUREDIMENSION_2D_ARRAY, TEXTUREDIMENSION_3D, TEXTUREDIMENSION_CUBE, TEXTUREDIMENSION_CUBE_ARRAY, TEXTURELOCK_NONE, TEXTURELOCK_READ, TEXTURELOCK_WRITE, TEXTUREPROJECTION_CUBE, TEXTUREPROJECTION_EQUIRECT, TEXTUREPROJECTION_NONE, TEXTUREPROJECTION_OCTAHEDRAL, TEXTURETYPE_DEFAULT, TEXTURETYPE_RGBE, TEXTURETYPE_RGBM, TEXTURETYPE_RGBP, TEXTURETYPE_SWIZZLEGGGR, TYPE_FLOAT16, TYPE_FLOAT32, TYPE_INT16, TYPE_INT32, TYPE_INT8, TYPE_UINT16, TYPE_UINT32, TYPE_UINT8, UNIFORMTYPE_BOOL, UNIFORMTYPE_BOOLARRAY, UNIFORMTYPE_BVEC2, UNIFORMTYPE_BVEC2ARRAY, UNIFORMTYPE_BVEC3, UNIFORMTYPE_BVEC3ARRAY, UNIFORMTYPE_BVEC4, UNIFORMTYPE_BVEC4ARRAY, UNIFORMTYPE_FLOAT, UNIFORMTYPE_FLOATARRAY, UNIFORMTYPE_INT, UNIFORMTYPE_INTARRAY, UNIFORMTYPE_ITEXTURE2D, UNIFORMTYPE_ITEXTURE2D_ARRAY, UNIFORMTYPE_ITEXTURE3D, UNIFORMTYPE_ITEXTURECUBE, UNIFORMTYPE_IVEC2, UNIFORMTYPE_IVEC2ARRAY, UNIFORMTYPE_IVEC3, UNIFORMTYPE_IVEC3ARRAY, UNIFORMTYPE_IVEC4, UNIFORMTYPE_IVEC4ARRAY, UNIFORMTYPE_MAT2, UNIFORMTYPE_MAT3, UNIFORMTYPE_MAT4, UNIFORMTYPE_MAT4ARRAY, UNIFORMTYPE_TEXTURE2D, UNIFORMTYPE_TEXTURE2D_ARRAY, UNIFORMTYPE_TEXTURE2D_SHADOW, UNIFORMTYPE_TEXTURE3D, UNIFORMTYPE_TEXTURECUBE, UNIFORMTYPE_TEXTURECUBE_SHADOW, UNIFORMTYPE_UINT, UNIFORMTYPE_UINTARRAY, UNIFORMTYPE_UTEXTURE2D, UNIFORMTYPE_UTEXTURE2D_ARRAY, UNIFORMTYPE_UTEXTURE3D, UNIFORMTYPE_UTEXTURECUBE, UNIFORMTYPE_UVEC2, UNIFORMTYPE_UVEC2ARRAY, UNIFORMTYPE_UVEC3, UNIFORMTYPE_UVEC3ARRAY, UNIFORMTYPE_UVEC4, UNIFORMTYPE_UVEC4ARRAY, UNIFORMTYPE_VEC2, UNIFORMTYPE_VEC2ARRAY, UNIFORMTYPE_VEC3, UNIFORMTYPE_VEC3ARRAY, UNIFORMTYPE_VEC4, UNIFORMTYPE_VEC4ARRAY, UNIFORM_BUFFER_DEFAULT_SLOT_NAME, UNUSED_UNIFORM_NAME, bindGroupNames, getPixelFormatArrayType, isCompressedPixelFormat, isIntegerPixelFormat, isSrgbPixelFormat, pixelFormatGammaToLinear, pixelFormatInfo, pixelFormatLinearToGamma, requiresManualGamma, semanticToLocation, typedArrayIndexFormats, typedArrayIndexFormatsByteSize, typedArrayToType, typedArrayTypes, typedArrayTypesByteSize, uniformTypeToName, uniformTypeToNameMapWGSL, uniformTypeToNameWGSL, uniformTypeToStorage, vertexTypesNames };
