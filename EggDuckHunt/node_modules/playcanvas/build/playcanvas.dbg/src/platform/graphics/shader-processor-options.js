import { BINDGROUP_VIEW } from './constants.js';

/**
 * @import { BindGroupFormat } from './bind-group-format.js'
 * @import { GraphicsDevice } from './graphics-device.js'
 * @import { UniformBufferFormat } from './uniform-buffer-format.js'
 * @import { VertexFormat } from './vertex-format.js'
 */ /**
 * Options to drive shader processing to add support for bind groups and uniform buffers.
 *
 * @ignore
 */ class ShaderProcessorOptions {
    /**
     * Get the bind group index for the uniform name.
     *
     * @param {string} name - The name of the uniform.
     * @returns {boolean} - Returns true if the uniform exists, false otherwise.
     */ hasUniform(name) {
        for(var i = 0; i < this.uniformFormats.length; i++){
            var uniformFormat = this.uniformFormats[i];
            if (uniformFormat == null ? undefined : uniformFormat.get(name)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Get the bind group texture slot for the texture uniform name.
     *
     * @param {string} name - The name of the texture uniform.
     * @returns {boolean} - Returns true if the texture uniform exists, false otherwise.
     */ hasTexture(name) {
        for(var i = 0; i < this.bindGroupFormats.length; i++){
            var groupFormat = this.bindGroupFormats[i];
            if (groupFormat == null ? undefined : groupFormat.getTexture(name)) {
                return true;
            }
        }
        return false;
    }
    getVertexElement(semantic) {
        var _this_vertexFormat;
        return (_this_vertexFormat = this.vertexFormat) == null ? undefined : _this_vertexFormat.elements.find((element)=>element.name === semantic);
    }
    /**
     * Generate unique key representing the processing options.
     *
     * @param {GraphicsDevice} device - The device.
     * @returns {string} - Returns the key.
     */ generateKey(device) {
        // TODO: Optimize. Uniform and BindGroup formats should have their keys evaluated in their
        // constructors, and here we should simply concatenate those.
        var key = JSON.stringify(this.uniformFormats) + JSON.stringify(this.bindGroupFormats);
        // WebGPU shaders are processed per vertex format
        if (device.isWebGPU) {
            var _this_vertexFormat;
            key += (_this_vertexFormat = this.vertexFormat) == null ? undefined : _this_vertexFormat.shaderProcessingHashString;
        }
        return key;
    }
    /**
     * Constructs shader processing options, used to process the shader for uniform buffer support.
     *
     * @param {UniformBufferFormat} [viewUniformFormat] - Format of the uniform buffer.
     * @param {BindGroupFormat} [viewBindGroupFormat] - Format of the bind group.
     * @param {VertexFormat} [vertexFormat] - Format of the vertex buffer.
     */ constructor(viewUniformFormat, viewBindGroupFormat, vertexFormat){
        /** @type {UniformBufferFormat[]} */ this.uniformFormats = [];
        /** @type {BindGroupFormat[]} */ this.bindGroupFormats = [];
        // construct a sparse array
        this.uniformFormats[BINDGROUP_VIEW] = viewUniformFormat;
        this.bindGroupFormats[BINDGROUP_VIEW] = viewBindGroupFormat;
        this.vertexFormat = vertexFormat;
    }
}

export { ShaderProcessorOptions };
