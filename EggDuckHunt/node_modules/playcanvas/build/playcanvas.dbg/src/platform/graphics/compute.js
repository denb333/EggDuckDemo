/**
 * @import { GraphicsDevice } from './graphics-device.js'
 * @import { IndexBuffer } from './index-buffer.js'
 * @import { ScopeId } from './scope-id.js'
 * @import { Shader } from './shader.js'
 * @import { StorageBuffer } from './storage-buffer.js'
 * @import { Texture } from './texture.js'
 * @import { VertexBuffer } from './vertex-buffer.js'
 */ /**
 * A helper class storing a parameter value as well as its scope ID.
 *
 * @ignore
 */ class ComputeParameter {
    constructor(){
        /** @type {ScopeId} */ this.scopeId = null;
    }
}
/**
 * A representation of a compute shader with the associated resources, that can be executed on the
 * GPU. Only supported on WebGPU platform.
 */ class Compute {
    /**
     * Sets a shader parameter on a compute instance.
     *
     * @param {string} name - The name of the parameter to set.
     * @param {number|number[]|Float32Array|Texture|StorageBuffer|VertexBuffer|IndexBuffer} value -
     * The value for the specified parameter.
     */ setParameter(name, value) {
        var param = this.parameters.get(name);
        if (!param) {
            param = new ComputeParameter();
            param.scopeId = this.device.scope.resolve(name);
            this.parameters.set(name, param);
        }
        param.value = value;
    }
    /**
     * Returns the value of a shader parameter from the compute instance.
     *
     * @param {string} name - The name of the parameter to get.
     * @returns {number|number[]|Float32Array|Texture|StorageBuffer|VertexBuffer|IndexBuffer|undefined}
     * The value of the specified parameter.
     */ getParameter(name) {
        var _this_parameters_get;
        return (_this_parameters_get = this.parameters.get(name)) == null ? undefined : _this_parameters_get.value;
    }
    /**
     * Deletes a shader parameter from the compute instance.
     *
     * @param {string} name - The name of the parameter to delete.
     */ deleteParameter(name) {
        this.parameters.delete(name);
    }
    /**
     * Apply the parameters to the scope.
     *
     * @ignore
     */ applyParameters() {
        for (var [, param] of this.parameters){
            param.scopeId.setValue(param.value);
        }
    }
    /**
     * Prepare the compute work dispatch.
     *
     * @param {number} x - X dimension of the grid of work-groups to dispatch.
     * @param {number} [y] - Y dimension of the grid of work-groups to dispatch.
     * @param {number} [z] - Z dimension of the grid of work-groups to dispatch.
     */ setupDispatch(x, y, z) {
        this.countX = x;
        this.countY = y;
        this.countZ = z;
    }
    /**
     * Create a compute instance. Note that this is supported on WebGPU only and is a no-op on
     * other platforms.
     *
     * @param {GraphicsDevice} graphicsDevice -
     * The graphics device.
     * @param {Shader} shader - The compute shader.
     * @param {string} [name] - The name of the compute instance, used for debugging only.
     */ constructor(graphicsDevice, shader, name = 'Unnamed'){
        /**
     * A compute shader.
     *
     * @type {Shader|null}
     * @ignore
     */ this.shader = null;
        /**
     * @type {Map<string, ComputeParameter>}
     * @ignore
     */ this.parameters = new Map();
        /**
     * @type {number}
     * @ignore
     */ this.countX = 1;
        this.device = graphicsDevice;
        this.shader = shader;
        this.name = name;
        if (graphicsDevice.supportsCompute) {
            this.impl = graphicsDevice.createComputeImpl(this);
        }
    }
}

export { Compute };
