var shadowCascadesPS = "\n\n// function which selects a shadow projection matrix index based on cascade distances \nint getShadowCascadeIndex(vec4 shadowCascadeDistances, int shadowCascadeCount) {\n\n    // depth in 0 .. far plane range\n    float depth = 1.0 / gl_FragCoord.w;\n\n    // 1.0 if depth >= distance, 0.0 otherwise\n    vec4 comparisons = step(shadowCascadeDistances, vec4(depth));\n\n    // sum is the index\n    int cascadeIndex = int(dot(comparisons, vec4(1.0)));\n\n    // limit to actual number of used cascades\n    return min(cascadeIndex, shadowCascadeCount - 1);\n}\n\n// function which modifies cascade index to dither between cascades\nint ditherShadowCascadeIndex(int cascadeIndex, vec4 shadowCascadeDistances, int shadowCascadeCount, float blendFactor) {\n \n    if (cascadeIndex < shadowCascadeCount - 1) {\n        float currentRangeEnd = shadowCascadeDistances[cascadeIndex];\n        float transitionStart = blendFactor * currentRangeEnd; // Start overlap factor away from the end distance\n        float depth = 1.0 / gl_FragCoord.w;\n\n        if (depth > transitionStart) {\n            // Calculate a transition factor (0.0 to 1.0) within the overlap range\n            float transitionFactor = smoothstep(transitionStart, currentRangeEnd, depth);\n\n            // Add pseudo-random dithering\n            // TODO: replace by user selectable dithering method\n            float dither = fract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453);\n            if (dither < transitionFactor) {\n                cascadeIndex += 1;\n            }\n        }\n    }\n\n    return cascadeIndex;\n}\n\nvoid fadeShadow(vec4 shadowCascadeDistances) {                  \n    // if the pixel is past the shadow distance, remove shadow\n    // this enforces straight line instead of corner of shadow which moves when camera rotates  \n    float depth = 1.0 / gl_FragCoord.w;\n    if (depth > shadowCascadeDistances.w) {\n        dShadowCoord.z = -9999999.0;\n    }\n}\n";

export { shadowCascadesPS as default };
