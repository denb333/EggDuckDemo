// Chunk that allows us to store all 32bits of float in a single RGBA8 texture without any loss of
// precision. The float value is encoded to RGBA8 and decoded back to float. Used as a fallback
// for platforms that do not support float textures but need to render to a float texture (without
// filtering)
var floatAsUintPS = "\n\n#ifndef FLOAT_AS_UINT\n#define FLOAT_AS_UINT\n\n// encode float value to RGBA8\nvec4 float2uint(float value) {\n    uint intBits = floatBitsToUint(value);\n    return vec4(\n        float((intBits >> 24u) & 0xFFu) / 255.0,\n        float((intBits >> 16u) & 0xFFu) / 255.0,\n        float((intBits >> 8u) & 0xFFu) / 255.0,\n        float(intBits & 0xFFu) / 255.0\n    );\n}\n\n// decode RGBA8 value to float\nfloat uint2float(vec4 value) {\n    uint intBits = \n        (uint(value.r * 255.0) << 24u) |\n        (uint(value.g * 255.0) << 16u) |\n        (uint(value.b * 255.0) << 8u) |\n        uint(value.a * 255.0);\n\n    return uintBitsToFloat(intBits);\n}\n\n#endif // FLOAT_AS_UINT\n";

export { floatAsUintPS as default };
