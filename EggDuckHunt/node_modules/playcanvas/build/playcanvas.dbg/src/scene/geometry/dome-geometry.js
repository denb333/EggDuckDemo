import { SphereGeometry } from './sphere-geometry.js';

/**
 * A procedural dome-shaped geometry.
 *
 * The size and tesselation properties of the dome can be controlled via constructor parameters.
 * Radius is fixed to 0.5.
 *
 * Note that the dome is created with UVs in the range of 0 to 1.
 *
 * @category Graphics
 */ class DomeGeometry extends SphereGeometry {
    /**
     * Create a new CylinderGeometry instance.
     *
     * @param {object} [opts] - An object that specifies optional inputs for the function as follows:
     * @param {number} [opts.latitudeBands] - The number of divisions along the latitudinal axis of the
     * sphere (defaults to 16).
     * @param {number} [opts.longitudeBands] - The number of divisions along the longitudinal axis of
     * the sphere (defaults to 16).
     */ constructor(opts = {}){
        // create a sphere geometry
        var radius = 0.5; // the math and constants are based on a unit sphere
        var _opts_latitudeBands;
        var latitudeBands = (_opts_latitudeBands = opts.latitudeBands) != null ? _opts_latitudeBands : 16;
        var _opts_longitudeBands;
        var longitudeBands = (_opts_longitudeBands = opts.longitudeBands) != null ? _opts_longitudeBands : 16;
        super({
            radius,
            latitudeBands,
            longitudeBands
        });
        // post-process the geometry to flatten the bottom hemisphere
        var bottomLimit = 0.1; // flatten bottom y-coordinate
        var curvatureRadius = 0.95; // normalized distance from the center that is completely flat
        var curvatureRadiusSq = curvatureRadius * curvatureRadius; // derived values
        var positions = this.positions;
        for(var i = 0; i < positions.length; i += 3){
            var x = positions[i] / radius;
            var y = positions[i + 1] / radius;
            var z = positions[i + 2] / radius;
            // flatten the lower hemisphere
            if (y < 0) {
                // scale vertices on the bottom
                y *= 0.3;
                // flatten the center
                if (x * x + z * z < curvatureRadiusSq) {
                    y = -0.1;
                }
            }
            // adjust y to have the center at the flat bottom
            y += bottomLimit;
            y *= radius;
            positions[i + 1] = y;
        }
    }
}

export { DomeGeometry };
