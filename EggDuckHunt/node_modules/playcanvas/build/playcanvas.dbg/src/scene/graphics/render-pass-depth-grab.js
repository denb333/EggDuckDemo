import { FILTER_NEAREST, ADDRESS_CLAMP_TO_EDGE, PIXELFORMAT_DEPTHSTENCIL, PIXELFORMAT_DEPTH, PIXELFORMAT_R32F } from '../../platform/graphics/constants.js';
import { DebugGraphics } from '../../platform/graphics/debug-graphics.js';
import { RenderPass } from '../../platform/graphics/render-pass.js';
import { RenderTarget } from '../../platform/graphics/render-target.js';
import { Texture } from '../../platform/graphics/texture.js';

// uniform name
var _depthUniformName = 'uSceneDepthMap';
/**
 * A render pass implementing grab of a depth buffer, used on WebGL 2 and WebGPU devices.
 *
 * @ignore
 */ class RenderPassDepthGrab extends RenderPass {
    destroy() {
        super.destroy();
        this.releaseRenderTarget(this.depthRenderTarget);
    }
    shouldReallocate(targetRT, sourceTexture) {
        // need to reallocate if dimensions don't match
        var width = (sourceTexture == null ? undefined : sourceTexture.width) || this.device.width;
        var height = (sourceTexture == null ? undefined : sourceTexture.height) || this.device.height;
        return !targetRT || width !== targetRT.width || height !== targetRT.height;
    }
    allocateRenderTarget(renderTarget, sourceRenderTarget, device, format, isDepth) {
        // allocate texture buffer
        var texture = new Texture(device, {
            name: _depthUniformName,
            format,
            width: sourceRenderTarget ? sourceRenderTarget.colorBuffer.width : device.width,
            height: sourceRenderTarget ? sourceRenderTarget.colorBuffer.height : device.height,
            mipmaps: false,
            minFilter: FILTER_NEAREST,
            magFilter: FILTER_NEAREST,
            addressU: ADDRESS_CLAMP_TO_EDGE,
            addressV: ADDRESS_CLAMP_TO_EDGE
        });
        if (renderTarget) {
            // if reallocating RT size, release previous framebuffer
            renderTarget.destroyFrameBuffers();
            // assign new texture
            if (isDepth) {
                renderTarget._depthBuffer = texture;
            } else {
                renderTarget._colorBuffer = texture;
                renderTarget._colorBuffers = [
                    texture
                ];
            }
        } else {
            // create new render target with the texture
            renderTarget = new RenderTarget({
                name: 'DepthGrabRT',
                colorBuffer: isDepth ? null : texture,
                depthBuffer: isDepth ? texture : null,
                depth: !isDepth,
                stencil: device.supportsStencil,
                autoResolve: false
            });
        }
        return renderTarget;
    }
    releaseRenderTarget(rt) {
        if (rt) {
            rt.destroyTextureBuffers();
            rt.destroy();
        }
    }
    before() {
        var _camera_renderTarget, _camera_renderTarget1;
        var camera = this.camera;
        var device = this.device;
        var _camera_renderTarget2;
        var destinationRt = (_camera_renderTarget2 = camera == null ? undefined : camera.renderTarget) != null ? _camera_renderTarget2 : device.backBuffer;
        var useDepthBuffer = true;
        var format = destinationRt.stencil ? PIXELFORMAT_DEPTHSTENCIL : PIXELFORMAT_DEPTH;
        if (device.isWebGPU) {
            var numSamples = destinationRt.samples;
            // when depth buffer is multi-sampled, instead of copying it out, we use custom shader to resolve it
            // to a R32F texture, used as a color attachment of the render target
            if (numSamples > 1) {
                format = PIXELFORMAT_R32F;
                useDepthBuffer = false;
            }
        }
        var _camera_renderTarget_depthBuffer;
        var sourceTexture = (_camera_renderTarget_depthBuffer = (_camera_renderTarget = camera.renderTarget) == null ? undefined : _camera_renderTarget.depthBuffer) != null ? _camera_renderTarget_depthBuffer : (_camera_renderTarget1 = camera.renderTarget) == null ? undefined : _camera_renderTarget1.colorBuffer;
        // allocate / resize existing RT as needed
        if (this.shouldReallocate(this.depthRenderTarget, sourceTexture)) {
            this.releaseRenderTarget(this.depthRenderTarget);
            this.depthRenderTarget = this.allocateRenderTarget(this.depthRenderTarget, camera.renderTarget, device, format, useDepthBuffer);
        }
        // assign uniform
        var colorBuffer = useDepthBuffer ? this.depthRenderTarget.depthBuffer : this.depthRenderTarget.colorBuffer;
        device.scope.resolve(_depthUniformName).setValue(colorBuffer);
    }
    execute() {
        var device = this.device;
        DebugGraphics.pushGpuMarker(device, 'GRAB-DEPTH');
        // WebGL2 multisampling depth handling: we resolve multi-sampled depth buffer to a single-sampled destination buffer.
        // We could use existing API and resolve depth first and then blit it to destination, but this avoids the extra copy.
        if (device.isWebGL2 && device.renderTarget.samples > 1) {
            // multi-sampled buffer
            var src = device.renderTarget.impl._glFrameBuffer;
            // single sampled destination buffer
            var dest = this.depthRenderTarget;
            device.renderTarget = dest;
            device.updateBegin();
            this.depthRenderTarget.impl.internalResolve(device, src, dest.impl._glFrameBuffer, this.depthRenderTarget, device.gl.DEPTH_BUFFER_BIT);
        } else {
            // copy depth
            device.copyRenderTarget(device.renderTarget, this.depthRenderTarget, false, true);
        }
        DebugGraphics.popGpuMarker(device);
    }
    constructor(device, camera){
        super(device), this.depthRenderTarget = null, this.camera = null;
        this.camera = camera;
    }
}

export { RenderPassDepthGrab };
