import { Debug } from '../../core/debug.js';
import { FILTER_LINEAR, FILTER_NEAREST, PIXELFORMAT_R32F, PIXELFORMAT_R16F, pixelFormatInfo, TEXHINT_SHADOWMAP, ADDRESS_CLAMP_TO_EDGE, FUNC_LESS } from '../../platform/graphics/constants.js';
import { RenderTarget } from '../../platform/graphics/render-target.js';
import { Texture } from '../../platform/graphics/texture.js';
import { SHADOW_VSM_32F, LIGHTTYPE_OMNI, shadowTypeInfo, SHADOW_PCSS_32F } from '../constants.js';

class ShadowMap {
    destroy() {
        // single texture is shared by all render targets, destroy it once
        if (this.texture) {
            this.texture.destroy();
            this.texture = null;
        }
        var targets = this.renderTargets;
        for(var i = 0; i < targets.length; i++){
            targets[i].destroy();
        }
        this.renderTargets.length = 0;
    }
    static getShadowFiltering(device, shadowType) {
        if (shadowType === SHADOW_VSM_32F) {
            return device.extTextureFloatLinear ? FILTER_LINEAR : FILTER_NEAREST;
        }
        return FILTER_LINEAR;
    }
    static create(device, light) {
        var shadowMap = null;
        if (light._type === LIGHTTYPE_OMNI) {
            shadowMap = this.createCubemap(device, light._shadowResolution, light._shadowType);
        } else {
            shadowMap = this.create2dMap(device, light._shadowResolution, light._shadowType);
        }
        return shadowMap;
    }
    // creates a shadow map which is used by the light texture atlas for clustered lighting
    static createAtlas(device, resolution, shadowType) {
        var shadowMap = this.create2dMap(device, resolution, shadowType);
        // copy the target 5 more times to allow unified access for point light faces
        var targets = shadowMap.renderTargets;
        var rt = targets[0];
        for(var i = 0; i < 5; i++){
            targets.push(rt);
        }
        return shadowMap;
    }
    static create2dMap(device, size, shadowType) {
        var _pixelFormatInfo_get;
        var shadowInfo = shadowTypeInfo.get(shadowType);
        Debug.assert(shadowInfo);
        var format = shadowInfo.format;
        // when F32 is needed but not supported, fallback to F16 (PCSS)
        if (format === PIXELFORMAT_R32F && !device.textureFloatRenderable && device.textureHalfFloatRenderable) {
            format = PIXELFORMAT_R16F;
        }
        var formatName = (_pixelFormatInfo_get = pixelFormatInfo.get(format)) == null ? undefined : _pixelFormatInfo_get.name;
        var filter = this.getShadowFiltering(device, shadowType);
        var texture = new Texture(device, {
            profilerHint: TEXHINT_SHADOWMAP,
            format: format,
            width: size,
            height: size,
            mipmaps: false,
            minFilter: filter,
            magFilter: filter,
            addressU: ADDRESS_CLAMP_TO_EDGE,
            addressV: ADDRESS_CLAMP_TO_EDGE,
            name: "ShadowMap2D_" + formatName
        });
        var target = null;
        if (shadowInfo == null ? undefined : shadowInfo.pcf) {
            // enable hardware PCF when sampling the depth texture
            texture.compareOnRead = true;
            texture.compareFunc = FUNC_LESS;
            // depthbuffer only
            target = new RenderTarget({
                depthBuffer: texture
            });
        } else {
            // encoded rgba depth
            target = new RenderTarget({
                colorBuffer: texture,
                depth: true
            });
        }
        // TODO: this is temporary, and will be handled on generic level for all render targets for WebGPU
        if (device.isWebGPU) {
            target.flipY = true;
        }
        return new ShadowMap(texture, [
            target
        ]);
    }
    static createCubemap(device, size, shadowType) {
        var _pixelFormatInfo_get;
        var shadowInfo = shadowTypeInfo.get(shadowType);
        Debug.assert(shadowInfo);
        var formatName = (_pixelFormatInfo_get = pixelFormatInfo.get(shadowInfo.format)) == null ? undefined : _pixelFormatInfo_get.name;
        var isPcss = shadowType === SHADOW_PCSS_32F;
        var filter = isPcss ? FILTER_NEAREST : FILTER_LINEAR;
        var cubemap = new Texture(device, {
            profilerHint: TEXHINT_SHADOWMAP,
            format: shadowInfo == null ? undefined : shadowInfo.format,
            width: size,
            height: size,
            cubemap: true,
            mipmaps: false,
            minFilter: filter,
            magFilter: filter,
            addressU: ADDRESS_CLAMP_TO_EDGE,
            addressV: ADDRESS_CLAMP_TO_EDGE,
            name: "ShadowMapCube_" + formatName
        });
        // enable hardware PCF when sampling the depth texture
        if (!isPcss) {
            cubemap.compareOnRead = true;
            cubemap.compareFunc = FUNC_LESS;
        }
        var targets = [];
        for(var i = 0; i < 6; i++){
            if (isPcss) {
                // color and depth buffer
                targets.push(new RenderTarget({
                    colorBuffer: cubemap,
                    face: i,
                    depth: true
                }));
            } else {
                // depth buffer only
                targets.push(new RenderTarget({
                    depthBuffer: cubemap,
                    face: i
                }));
            }
        }
        return new ShadowMap(cubemap, targets);
    }
    constructor(texture, targets){
        // the actual texture buffer that is shared by shadow map render targets
        this.texture = texture;
        // set to true if the shadow map is owned by the shadow map cache
        this.cached = false;
        // an array of render targets:
        // 1 for directional and spot light
        // 6 for omni light
        this.renderTargets = targets;
    }
}

export { ShadowMap };
