import { TRACEID_RENDER_PASS_DETAIL } from '../../core/constants.js';
import { Debug } from '../../core/debug.js';
import { now } from '../../core/time.js';
import { Tracing } from '../../core/tracing.js';
import { BlendState } from '../../platform/graphics/blend-state.js';
import { DebugGraphics } from '../../platform/graphics/debug-graphics.js';
import { RenderPass } from '../../platform/graphics/render-pass.js';
import { RenderAction } from '../composition/render-action.js';
import { EVENT_PRERENDER, EVENT_POSTRENDER, EVENT_PRERENDER_LAYER, SHADER_FORWARD, EVENT_POSTRENDER_LAYER } from '../constants.js';

/**
 * @import { CameraComponent } from '../../framework/components/camera/component.js'
 * @import { LayerComposition } from '../composition/layer-composition.js'
 * @import { Layer } from '../layer.js'
 * @import { Renderer } from './renderer.js'
 * @import { Scene } from '../scene.js'
 */ /**
 * A render pass used render a set of layers using a camera.
 *
 * @ignore
 */ class RenderPassForward extends RenderPass {
    get rendersAnything() {
        return this.renderActions.length > 0;
    }
    addRenderAction(renderAction) {
        this.renderActions.push(renderAction);
    }
    /**
     * Adds a layer to be rendered by this render pass.
     *
     * @param {CameraComponent} cameraComponent - The camera component that is used to render the
     * layers.
     * @param {Layer} layer - The layer to be added.
     * @param {boolean} transparent - True if the layer is transparent.
     * @param {boolean} autoClears - True if the render target should be cleared based on the camera
     * and layer clear flags. Defaults to true.
     */ addLayer(cameraComponent, layer, transparent, autoClears) {
        if (autoClears === undefined) autoClears = true;
        Debug.assert(cameraComponent);
        Debug.assert(this.renderTarget !== undefined, 'Render pass needs to be initialized before adding layers');
        Debug.assert(cameraComponent.camera.layersSet.has(layer.id), "Camera " + cameraComponent.entity.name + " does not render layer " + layer.name + ".");
        var ra = new RenderAction();
        ra.renderTarget = this.renderTarget;
        ra.camera = cameraComponent;
        ra.layer = layer;
        ra.transparent = transparent;
        // camera / layer clear flags
        if (autoClears) {
            var firstRa = this.renderActions.length === 0;
            ra.setupClears(firstRa ? cameraComponent : undefined, layer);
        }
        this.addRenderAction(ra);
    }
    /**
     * Adds layers to be rendered by this render pass, starting from the given index of the layer
     * in the layer composition, till the end of the layer list, or till the last layer with the
     * given id and transparency is reached (inclusive). Note that only layers that are rendered by
     * the specified camera are added.
     *
     * @param {LayerComposition} composition - The layer composition containing the layers to be
     * added, typically the scene layer composition.
     * @param {CameraComponent} cameraComponent - The camera component that is used to render the
     * layers.
     * @param {number} startIndex - The index of the first layer to be considered for adding.
     * @param {boolean} firstLayerClears - True if the first layer added should clear the render
     * target.
     * @param {number} [lastLayerId] - The id of the last layer to be added. If not specified, all
     * layers till the end of the layer list are added.
     * @param {boolean} [lastLayerIsTransparent] - True if the last layer to be added is transparent.
     * Defaults to true.
     * @returns {number} Returns the index of last layer added.
     */ addLayers(composition, cameraComponent, startIndex, firstLayerClears, lastLayerId, lastLayerIsTransparent) {
        if (lastLayerIsTransparent === undefined) lastLayerIsTransparent = true;
        var { layerList, subLayerList } = composition;
        var clearRenderTarget = firstLayerClears;
        var index = startIndex;
        while(index < layerList.length){
            var layer = layerList[index];
            var isTransparent = subLayerList[index];
            var renderedByCamera = cameraComponent.camera.layersSet.has(layer.id);
            // add it for rendering
            if (renderedByCamera) {
                this.addLayer(cameraComponent, layer, isTransparent, clearRenderTarget);
                clearRenderTarget = false;
            }
            index++;
            // stop at last requested layer
            if (layer.id === lastLayerId && isTransparent === lastLayerIsTransparent) {
                break;
            }
        }
        return index;
    }
    updateDirectionalShadows() {
        // add directional shadow passes if needed for the cameras used in this render pass
        var { renderer, renderActions } = this;
        for(var i = 0; i < renderActions.length; i++){
            var renderAction = renderActions[i];
            var cameraComp = renderAction.camera;
            var camera = cameraComp.camera;
            // if this camera uses directional shadow lights
            var shadowDirLights = this.renderer.cameraDirShadowLights.get(camera);
            if (shadowDirLights) {
                for(var l = 0; l < shadowDirLights.length; l++){
                    var light = shadowDirLights[l];
                    // the the shadow map is not already rendered for this light
                    if (renderer.dirLightShadows.get(light) !== camera) {
                        renderer.dirLightShadows.set(light, camera);
                        // render the shadow before this render pass
                        var shadowPass = renderer._shadowRendererDirectional.getLightRenderPass(light, camera);
                        if (shadowPass) {
                            this.beforePasses.push(shadowPass);
                        }
                    }
                }
            }
        }
    }
    updateClears() {
        // based on the first render action
        var renderAction = this.renderActions[0];
        if (renderAction) {
            // set up clear params if the camera covers the full viewport
            var cameraComponent = renderAction.camera;
            var camera = cameraComponent.camera;
            var fullSizeClearRect = camera.fullSizeClearRect;
            this.setClearColor(fullSizeClearRect && renderAction.clearColor ? camera.clearColor : undefined);
            this.setClearDepth(fullSizeClearRect && renderAction.clearDepth && !this.noDepthClear ? camera.clearDepth : undefined);
            this.setClearStencil(fullSizeClearRect && renderAction.clearStencil ? camera.clearStencil : undefined);
        }
    }
    frameUpdate() {
        super.frameUpdate();
        this.updateDirectionalShadows();
        this.updateClears();
    }
    before() {
        var { renderActions } = this;
        // onPreRender events
        for(var i = 0; i < renderActions.length; i++){
            var ra = renderActions[i];
            if (ra.firstCameraUse) {
                this.scene.fire(EVENT_PRERENDER, ra.camera);
            }
        }
    }
    execute() {
        var _this, _loop = function(i) {
            var ra = renderActions[i];
            var layer = ra.layer;
            Debug.call(()=>{
                var compLayer = layerComposition.getLayerByName(layer.name);
                if (!compLayer) {
                    Debug.warnOnce("Layer " + layer.name + " is not found in the scene and will not be rendered. Your render pass setup might need to be updated.");
                }
            });
            if (layerComposition.isEnabled(layer, ra.transparent)) {
                _this.renderRenderAction(ra, i === 0);
            }
        };
        var { layerComposition, renderActions } = this;
        for(var i = 0; i < renderActions.length; i++)_this = this, _loop(i);
    }
    after() {
        // onPostRender events
        for(var i = 0; i < this.renderActions.length; i++){
            var ra = this.renderActions[i];
            if (ra.lastCameraUse) {
                this.scene.fire(EVENT_POSTRENDER, ra.camera);
            }
        }
        // remove shadow before-passes
        this.beforePasses.length = 0;
    }
    /**
     * @param {RenderAction} renderAction - The render action.
     * @param {boolean} firstRenderAction - True if this is the first render action in the render pass.
     */ renderRenderAction(renderAction, firstRenderAction) {
        var { renderer, scene } = this;
        var device = renderer.device;
        // layer
        var { layer, transparent, camera } = renderAction;
        DebugGraphics.pushGpuMarker(this.device, "Camera: " + (camera ? camera.entity.name : 'Unnamed') + ", Layer: " + layer.name + "(" + (transparent ? 'TRANSP' : 'OPAQUE') + ")");
        var drawTime = now();
        if (camera) {
            var _camera_camera_shaderPassInfo;
            // override gamma correction and tone mapping settings
            var originalGammaCorrection = camera.gammaCorrection;
            var originalToneMapping = camera.toneMapping;
            if (this.gammaCorrection !== undefined) camera.gammaCorrection = this.gammaCorrection;
            if (this.toneMapping !== undefined) camera.toneMapping = this.toneMapping;
            // layer pre render event
            scene.fire(EVENT_PRERENDER_LAYER, camera, layer, transparent);
            var options = {
                lightClusters: renderAction.lightClusters
            };
            var _camera_camera_shaderPassInfo_index;
            // shader pass - use setting from camera if available, otherwise forward
            var shaderPass = (_camera_camera_shaderPassInfo_index = (_camera_camera_shaderPassInfo = camera.camera.shaderPassInfo) == null ? undefined : _camera_camera_shaderPassInfo.index) != null ? _camera_camera_shaderPassInfo_index : SHADER_FORWARD;
            // if this is not a first render action to the render target, or if the render target was not
            // fully cleared on pass start, we need to execute clears here
            if (!firstRenderAction || !camera.camera.fullSizeClearRect) {
                options.clearColor = renderAction.clearColor;
                options.clearDepth = renderAction.clearDepth;
                options.clearStencil = renderAction.clearStencil;
            }
            var _renderAction_renderTarget;
            var renderTarget = (_renderAction_renderTarget = renderAction.renderTarget) != null ? _renderAction_renderTarget : device.backBuffer;
            renderer.renderForwardLayer(camera.camera, renderTarget, layer, transparent, shaderPass, renderAction.viewBindGroups, options);
            // Revert temp frame stuff
            // TODO: this should not be here, as each rendering / clearing should explicitly set up what
            // it requires (the properties are part of render pipeline on WebGPU anyways)
            device.setBlendState(BlendState.NOBLEND);
            device.setStencilState(null, null);
            device.setAlphaToCoverage(false);
            // layer post render event
            scene.fire(EVENT_POSTRENDER_LAYER, camera, layer, transparent);
            // restore gamma correction and tone mapping settings
            if (this.gammaCorrection !== undefined) camera.gammaCorrection = originalGammaCorrection;
            if (this.toneMapping !== undefined) camera.toneMapping = originalToneMapping;
        }
        DebugGraphics.popGpuMarker(this.device);
        layer._renderTime += now() - drawTime;
    }
    log(device, index) {
        super.log(device, index);
        if (Tracing.get(TRACEID_RENDER_PASS_DETAIL)) {
            var { layerComposition } = this;
            this.renderActions.forEach((ra, index)=>{
                var layer = ra.layer;
                var enabled = layer.enabled && layerComposition.isEnabled(layer, ra.transparent);
                var camera = ra.camera;
                Debug.trace(TRACEID_RENDER_PASS_DETAIL, "    " + index + ":" + (" Cam: " + (camera ? camera.entity.name : '-')).padEnd(22, ' ') + (" Lay: " + layer.name).padEnd(22, ' ') + (ra.transparent ? ' TRANSP' : ' OPAQUE') + (enabled ? ' ENABLED' : ' DISABLED') + (" Meshes: " + layer.meshInstances.length).padEnd(5, ' '));
            });
        }
    }
    constructor(device, layerComposition, scene, renderer){
        super(device), /**
     * @type {RenderAction[]}
     */ this.renderActions = [], /**
     * If true, do not clear the depth buffer before rendering, as it was already primed by a depth
     * pre-pass.
     *
     * @type {boolean}
     */ this.noDepthClear = false;
        this.layerComposition = layerComposition;
        this.scene = scene;
        this.renderer = renderer;
    }
}

export { RenderPassForward };
