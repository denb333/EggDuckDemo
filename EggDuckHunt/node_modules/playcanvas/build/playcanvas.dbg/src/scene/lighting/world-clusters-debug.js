import { Color } from '../../core/math/color.js';
import { Mat4 } from '../../core/math/mat4.js';
import { Vec3 } from '../../core/math/vec3.js';
import { PRIMITIVE_TRIANGLES } from '../../platform/graphics/constants.js';
import { BLEND_ADDITIVEALPHA } from '../constants.js';
import { GraphNode } from '../graph-node.js';
import { Mesh } from '../mesh.js';
import { MeshInstance } from '../mesh-instance.js';
import { StandardMaterial } from '../materials/standard-material.js';

class WorldClustersDebug {
    static render(worldClusters, scene) {
        var device = scene.device;
        var cells = worldClusters.cells;
        var lightsBuffer = worldClusters.lightsBuffer;
        var boundsMin = lightsBuffer.boundsMin;
        var boundsDelta = lightsBuffer.boundsDelta;
        var boundsMax = boundsMin.clone().add(boundsDelta);
        var cellDelta = lightsBuffer.boundsDelta.clone().div(cells);
        var gridPositions = WorldClustersDebug.gridPositions;
        var gridColors = WorldClustersDebug.gridColors;
        var c1 = new Color(0.3, 0.3, 0.3);
        var renderCellLines = (countA, countB, minA, deltaA, minB, deltaB, minC, maxC, order)=>{
            for(var a = 0; a <= countA; a++){
                for(var b = 0; b <= countB; b++){
                    var aa = minA + a * deltaA;
                    var bb = minB + b * deltaB;
                    if (order === 0) {
                        gridPositions.push(aa, minC, bb, aa, maxC, bb);
                    } else if (order === 1) {
                        gridPositions.push(aa, bb, minC, aa, bb, maxC);
                    } else if (order === 2) {
                        gridPositions.push(minC, aa, bb, maxC, aa, bb);
                    }
                }
            }
        };
        // generate grid lines
        renderCellLines(cells.x, cells.z, boundsMin.x, cellDelta.x, boundsMin.z, cellDelta.z, boundsMin.y, boundsMax.y, 0);
        renderCellLines(cells.x, cells.y, boundsMin.x, cellDelta.x, boundsMin.y, cellDelta.y, boundsMin.z, boundsMax.z, 1);
        renderCellLines(cells.y, cells.z, boundsMin.y, cellDelta.y, boundsMin.z, cellDelta.z, boundsMin.x, boundsMax.x, 2);
        // render grid lines
        if (gridPositions.length) {
            // update colors only when needed
            var numVerts = gridPositions.length / 3;
            if (numVerts !== gridColors.length / 4) {
                gridColors.length = 0;
                for(var i = 0; i < numVerts; i++){
                    gridColors.push(c1.r, c1.g, c1.b, c1.a);
                }
            }
            scene.drawLineArrays(gridPositions, gridColors);
            gridPositions.length = 0;
        }
        // render cell occupancy
        var mesh = WorldClustersDebug.mesh;
        if (!mesh) {
            mesh = new Mesh(device);
            mesh.clear(true, true);
            WorldClustersDebug.mesh = mesh;
        }
        var positions = [];
        var colors = [];
        var indices = [];
        var divX = worldClusters._cells.x;
        var divZ = worldClusters._cells.z;
        var counts = worldClusters.counts;
        var limit = worldClusters._maxCellLightCount;
        var min = new Vec3();
        var max = new Vec3();
        var col = new Vec3();
        var step = boundsDelta.clone().div(cells);
        // add cubes with a color representing cell occupancy to the dynamic mesh
        var cubes = 0;
        for(var x = 0; x < cells.x; x++){
            for(var z = 0; z < cells.z; z++){
                for(var y = 0; y < cells.y; y++){
                    var clusterIndex = x + divX * (z + y * divZ);
                    var count = counts[clusterIndex];
                    if (count > 0) {
                        // cube corners
                        min.x = boundsMin.x + step.x * x;
                        min.y = boundsMin.y + step.y * y;
                        min.z = boundsMin.z + step.z * z;
                        max.add2(min, step);
                        positions.push(min.x, min.y, max.z);
                        positions.push(max.x, min.y, max.z);
                        positions.push(max.x, max.y, max.z);
                        positions.push(min.x, max.y, max.z);
                        positions.push(max.x, min.y, min.z);
                        positions.push(min.x, min.y, min.z);
                        positions.push(min.x, max.y, min.z);
                        positions.push(max.x, max.y, min.z);
                        col.lerp(WorldClustersDebug.colorLow, WorldClustersDebug.colorHigh, count / limit).round();
                        for(var c = 0; c < 8; c++){
                            colors.push(col.x, col.y, col.z, 1);
                        }
                        // back
                        indices.push(cubes * 8 + 0, cubes * 8 + 1, cubes * 8 + 3);
                        indices.push(cubes * 8 + 3, cubes * 8 + 1, cubes * 8 + 2);
                        // front
                        indices.push(cubes * 8 + 4, cubes * 8 + 5, cubes * 8 + 7);
                        indices.push(cubes * 8 + 7, cubes * 8 + 5, cubes * 8 + 6);
                        // top
                        indices.push(cubes * 8 + 3, cubes * 8 + 2, cubes * 8 + 6);
                        indices.push(cubes * 8 + 2, cubes * 8 + 7, cubes * 8 + 6);
                        // bottom
                        indices.push(cubes * 8 + 1, cubes * 8 + 0, cubes * 8 + 4);
                        indices.push(cubes * 8 + 0, cubes * 8 + 5, cubes * 8 + 4);
                        // right
                        indices.push(cubes * 8 + 1, cubes * 8 + 4, cubes * 8 + 2);
                        indices.push(cubes * 8 + 4, cubes * 8 + 7, cubes * 8 + 2);
                        // left
                        indices.push(cubes * 8 + 5, cubes * 8 + 0, cubes * 8 + 6);
                        indices.push(cubes * 8 + 0, cubes * 8 + 3, cubes * 8 + 6);
                        cubes++;
                    }
                }
            }
        }
        if (cubes) {
            mesh.setPositions(positions);
            mesh.setColors32(colors);
            mesh.setIndices(indices);
            mesh.update(PRIMITIVE_TRIANGLES, false);
            if (!WorldClustersDebug.meshInstance) {
                var material = new StandardMaterial();
                material.useLighting = false;
                material.emissive = new Color(1, 1, 1);
                material.emissiveVertexColor = true;
                material.blendType = BLEND_ADDITIVEALPHA;
                material.depthWrite = false;
                material.update();
                var node = new GraphNode('WorldClustersDebug');
                node.worldTransform = Mat4.IDENTITY;
                node._dirtyWorld = node._dirtyNormal = false;
                WorldClustersDebug.meshInstance = new MeshInstance(mesh, material, node);
                WorldClustersDebug.meshInstance.cull = false;
            }
            // render
            var meshInstance = WorldClustersDebug.meshInstance;
            scene.immediate.drawMesh(meshInstance.material, meshInstance.node.worldTransform, null, meshInstance, scene.defaultDrawLayer);
        }
    }
}
WorldClustersDebug.gridPositions = [];
WorldClustersDebug.gridColors = [];
WorldClustersDebug.mesh = null;
WorldClustersDebug.meshInstance = null;
WorldClustersDebug.colorLow = new Vec3(1, 1, 1);
WorldClustersDebug.colorHigh = new Vec3(40, 0, 0);

export { WorldClustersDebug };
