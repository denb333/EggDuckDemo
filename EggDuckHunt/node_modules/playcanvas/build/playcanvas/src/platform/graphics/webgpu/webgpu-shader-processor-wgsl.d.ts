/**
 * Pure static class implementing processing of WGSL shaders. It allocates fixed locations for
 * attributes, and handles conversion of uniforms to uniform buffers.
 */
export class WebgpuShaderProcessorWGSL {
    /**
     * Process the shader.
     *
     * @param {GraphicsDevice} device - The graphics device.
     * @param {object} shaderDefinition - The shader definition.
     * @param {Shader} shader - The shader.
     * @returns {object} - The processed shader data.
     */
    static run(device: GraphicsDevice, shaderDefinition: object, shader: Shader): object;
    static extract(src: any): {
        src: any;
        attributes: string[];
        varyings: string[];
        uniforms: string[];
        resources: string[];
    };
    /**
     * Process the lines with uniforms. The function receives the lines containing all uniforms,
     * both numerical as well as textures/samplers. The function also receives the format of uniform
     * buffers (numerical) and bind groups (textures) for view and material level. All uniforms that
     * match any of those are ignored, as those would be supplied by view / material level buffers.
     * All leftover uniforms create uniform buffer and bind group for the mesh itself, containing
     * uniforms that change on the level of the mesh.
     *
     * @param {GraphicsDevice} device - The graphics device.
     * @param {Array<UniformLine>} uniforms - Lines containing uniforms.
     * @param {ShaderProcessorOptions} processingOptions - Uniform formats.
     * @param {Shader} shader - The shader definition.
     * @returns {object} - The uniform data. Returns a shader code block containing uniforms, to be
     * inserted into the shader, as well as generated uniform format structures for the mesh level.
     */
    static processUniforms(device: GraphicsDevice, uniforms: Array<UniformLine>, processingOptions: ShaderProcessorOptions, shader: Shader): object;
    /**
     * Source code references uniforms as `uniform.name`, but swap those to reference the actual uniform buffer
     * the uniform was assigned to, for example `ub_view.name`.
     *
     * @param {string} source - The source code.
     * @param {Array<UniformLine>} uniforms - Lines containing uniforms.
     * @returns {string} - The source code with updated uniform references.
     */
    static renameUniformAccess(source: string, uniforms: Array<UniformLine>): string;
    static processResources(device: any, resources: any, processingOptions: any, shader: any): {
        code: string;
        meshBindGroupFormat: BindGroupFormat;
    };
    /**
     * Generates a shader code for a uniform buffer, something like:
     * ```
     *     struct ub_view { matrix_viewProjection : mat4x4f }
     *     @group(0) @binding(0) var<uniform> ubView : ub_view;
     * ```
     *
     * @param {UniformBufferFormat} ubFormat - Format of the uniform buffer.
     * @param {number} bindGroup - The bind group index.
     * @param {number} bindIndex - The bind index.
     * @returns {string} - The shader code for the uniform buffer.
     * @private
     */
    private static getUniformShaderDeclaration;
    /**
     * Generates a shader code for a bind group, something like:
     * ```
     *    @group(0) @binding(0) var diffuseTexture: texture_2d<f32>;
     *    @group(0) @binding(1) var diffuseTexture_sampler: sampler;  // optional
     * ```
     * @param {BindGroupFormat} format - The format of the bind group.
     * @param {number} bindGroup - The bind group index.
     * @param {number} startBindIndex - The starting bind index.
     * @returns {string} - The shader code for the bind group.
     */
    static getTextureShaderDeclaration(format: BindGroupFormat, bindGroup: number, startBindIndex: number): string;
    static processVaryings(varyingLines: any, varyingMap: any, isVertex: any): string;
    static generateFragmentOutputStruct(src: any, numRenderTargets: any): string;
    static processAttributes(attributeLines: any, shaderDefinitionAttributes: any, processingOptions: any): string;
    static cutOut(src: any, start: any, end: any, replacement: any): any;
}
import type { GraphicsDevice } from '../graphics-device.js';
import type { Shader } from '../shader.js';
declare class UniformLine {
    constructor(line: any, shader: any);
    /**
     * A name of the ub buffer which this uniform is assigned to.
     *
     * @type {string|null}
     */
    ubName: string | null;
    line: any;
    name: any;
    type: any;
}
import type { ShaderProcessorOptions } from '../shader-processor-options.js';
import { BindGroupFormat } from '../bind-group-format.js';
export {};
