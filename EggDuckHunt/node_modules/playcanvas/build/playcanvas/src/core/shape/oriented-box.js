import { Mat4 } from '../math/mat4.js';
import { Vec3 } from '../math/vec3.js';
import { BoundingBox } from './bounding-box.js';
import { BoundingSphere } from './bounding-sphere.js';
import { Ray } from './ray.js';

var tmpRay = new Ray();
var tmpVec3 = new Vec3();
var tmpSphere = new BoundingSphere();
var tmpMat4 = new Mat4();
class OrientedBox {
		set worldTransform(value) {
				this._worldTransform.copy(value);
				this._modelTransform.copy(value).invert();
		}
		get worldTransform() {
				return this._worldTransform;
		}
		intersectsRay(ray, point) {
				this._modelTransform.transformPoint(ray.origin, tmpRay.origin);
				this._modelTransform.transformVector(ray.direction, tmpRay.direction);
				if (point) {
						var result = this._aabb._intersectsRay(tmpRay, point);
						tmpMat4.copy(this._modelTransform).invert().transformPoint(point, point);
						return result;
				}
				return this._aabb._fastIntersectsRay(tmpRay);
		}
		containsPoint(point) {
				this._modelTransform.transformPoint(point, tmpVec3);
				return this._aabb.containsPoint(tmpVec3);
		}
		intersectsBoundingSphere(sphere) {
				this._modelTransform.transformPoint(sphere.center, tmpSphere.center);
				tmpSphere.radius = sphere.radius;
				if (this._aabb.intersectsBoundingSphere(tmpSphere)) {
						return true;
				}
				return false;
		}
		constructor(worldTransform = new Mat4(), halfExtents){
				this.halfExtents = new Vec3(0.5, 0.5, 0.5);
				if (halfExtents) {
						this.halfExtents.copy(halfExtents);
				}
				this._modelTransform = worldTransform.clone().invert();
				this._worldTransform = worldTransform.clone();
				this._aabb = new BoundingBox(new Vec3(), this.halfExtents);
		}
}

export { OrientedBox };
