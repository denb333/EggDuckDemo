var clusteredLightUtilsPS = "\nvec2 getCubemapFaceCoordinates(const vec3 dir, out float faceIndex, out vec2 tileOffset)\n{\n	vec3 vAbs = abs(dir);\n	float ma;\n	vec2 uv;\n	if (vAbs.z >= vAbs.x && vAbs.z >= vAbs.y) {\n		faceIndex = dir.z < 0.0 ? 5.0 : 4.0;\n		ma = 0.5 / vAbs.z;\n		uv = vec2(dir.z < 0.0 ? -dir.x : dir.x, -dir.y);\n		tileOffset.x = 2.0;\n		tileOffset.y = dir.z < 0.0 ? 1.0 : 0.0;\n	} else if(vAbs.y >= vAbs.x) {\n		faceIndex = dir.y < 0.0 ? 3.0 : 2.0;\n		ma = 0.5 / vAbs.y;\n		uv = vec2(dir.x, dir.y < 0.0 ? -dir.z : dir.z);\n		tileOffset.x = 1.0;\n		tileOffset.y = dir.y < 0.0 ? 1.0 : 0.0;\n	} else {\n		faceIndex = dir.x < 0.0 ? 1.0 : 0.0;\n		ma = 0.5 / vAbs.x;\n		uv = vec2(dir.x < 0.0 ? dir.z : -dir.z, -dir.y);\n		tileOffset.x = 0.0;\n		tileOffset.y = dir.x < 0.0 ? 1.0 : 0.0;\n	}\n	return uv * ma + 0.5;\n}\nvec2 getCubemapAtlasCoordinates(const vec3 omniAtlasViewport, float shadowEdgePixels, float shadowTextureResolution, const vec3 dir) {\n	float faceIndex;\n	vec2 tileOffset;\n	vec2 uv = getCubemapFaceCoordinates(dir, faceIndex, tileOffset);\n	float atlasFaceSize = omniAtlasViewport.z;\n	float tileSize = shadowTextureResolution * atlasFaceSize;\n	float offset = shadowEdgePixels / tileSize;\n	uv = uv * vec2(1.0 - offset * 2.0) + vec2(offset * 1.0);\n	uv *= atlasFaceSize;\n	uv += tileOffset * atlasFaceSize;\n	uv += omniAtlasViewport.xy;\n	return uv;\n}\n";

export { clusteredLightUtilsPS as default };
