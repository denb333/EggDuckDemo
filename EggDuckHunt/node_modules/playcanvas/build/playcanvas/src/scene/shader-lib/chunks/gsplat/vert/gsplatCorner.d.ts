declare const _default: "\nuniform vec2 viewport;                  // viewport dimensions\nuniform vec4 camera_params;             // 1 / far, far, near, isOrtho\n\n// calculate the clip-space offset from the center for this gaussian\nbool initCorner(SplatSource source, SplatCenter center, out SplatCorner corner) {\n    // get covariance\n    vec3 covA, covB;\n    readCovariance(source, covA, covB);\n\n    mat3 Vrk = mat3(\n        covA.x, covA.y, covA.z, \n        covA.y, covB.x, covB.y,\n        covA.z, covB.y, covB.z\n    );\n\n    float focal = viewport.x * center.projMat00;\n\n    vec3 v = camera_params.w == 1.0 ? vec3(0.0, 0.0, 1.0) : center.view.xyz;\n    float J1 = focal / v.z;\n    vec2 J2 = -J1 / v.z * v.xy;\n    mat3 J = mat3(\n        J1, 0.0, J2.x, \n        0.0, J1, J2.y, \n        0.0, 0.0, 0.0\n    );\n\n    mat3 W = transpose(mat3(center.modelView));\n    mat3 T = W * J;\n    mat3 cov = transpose(T) * Vrk * T;\n\n    float diagonal1 = cov[0][0] + 0.3;\n    float offDiagonal = cov[0][1];\n    float diagonal2 = cov[1][1] + 0.3;\n\n    float mid = 0.5 * (diagonal1 + diagonal2);\n    float radius = length(vec2((diagonal1 - diagonal2) / 2.0, offDiagonal));\n    float lambda1 = mid + radius;\n    float lambda2 = max(mid - radius, 0.1);\n\n    float l1 = 2.0 * min(sqrt(2.0 * lambda1), 1024.0);\n    float l2 = 2.0 * min(sqrt(2.0 * lambda2), 1024.0);\n\n    // early-out gaussians smaller than 2 pixels\n    if (l1 < 2.0 && l2 < 2.0) {\n        return false;\n    }\n\n    // perform cull against x/y axes\n    if (any(greaterThan(abs(center.proj.xy) - vec2(l1, l2) / viewport * center.proj.w, center.proj.ww))) {\n        return false;\n    }\n\n    vec2 diagonalVector = normalize(vec2(offDiagonal, lambda1 - diagonal1));\n    vec2 v1 = l1 * diagonalVector;\n    vec2 v2 = l2 * vec2(diagonalVector.y, -diagonalVector.x);\n\n    corner.offset = (source.cornerUV.x * v1 + source.cornerUV.y * v2) / viewport * center.proj.w;\n    corner.uv = source.cornerUV;\n\n    return true;\n}\n";
export default _default;
