var shadowSoftPS = "\nhighp float fractSinRand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot(uv.xy, vec2(a, b)), sn = mod(dt, PI);\n	return fract(sin(sn) * c);\n}\nstruct PoissonDiskData {\n	float invNumSamples;\n	float angleStep;\n	float initialAngle;\n	float currentRadius;\n	float currentAngle;\n};\nvoid preparePoissonConstants(out PoissonDiskData data, int sampleCount, int numRings, float randomSeed) {\n	const float pi2 = 6.28318530718;\n	data.invNumSamples = 1.0 / float(sampleCount);\n	data.angleStep = pi2 * float(numRings) * data.invNumSamples;\n	data.initialAngle = randomSeed * pi2;\n	data.currentRadius = data.invNumSamples;\n	data.currentAngle = data.initialAngle;\n}\nvec2 generatePoissonSample(inout PoissonDiskData data) {\n	vec2 offset = vec2(cos(data.currentAngle), sin(data.currentAngle)) * pow(data.currentRadius, 0.75);\n	data.currentRadius += data.invNumSamples;\n	data.currentAngle += data.angleStep;\n	return offset;\n}\nvoid PCSSFindBlocker(TEXTURE_ACCEPT(shadowMap), out float avgBlockerDepth, out int numBlockers,\n	vec2 shadowCoords, float z, int shadowBlockerSamples, float penumbraSize, float invShadowMapSize, float randomSeed) {\n	PoissonDiskData poissonData;\n	preparePoissonConstants(poissonData, shadowBlockerSamples, 11, randomSeed);\n	float searchWidth = penumbraSize * invShadowMapSize;\n	float blockerSum = 0.0;\n	numBlockers = 0;\n	for( int i = 0; i < shadowBlockerSamples; ++i ) {\n		vec2 poissonUV = generatePoissonSample(poissonData);\n		vec2 sampleUV = shadowCoords + poissonUV * searchWidth;\n		float shadowMapDepth = texture2DLod(shadowMap, sampleUV, 0.0).r;\n		if ( shadowMapDepth < z ) {\n			blockerSum += shadowMapDepth;\n			numBlockers++;\n		}\n	}\n	avgBlockerDepth = blockerSum / float(numBlockers);\n}\nfloat PCSSFilter(TEXTURE_ACCEPT(shadowMap), vec2 uv, float receiverDepth, int shadowSamples, float filterRadius, float randomSeed) {\n \n	PoissonDiskData poissonData;\n	preparePoissonConstants(poissonData, shadowSamples, 11, randomSeed);\n	float sum = 0.0f;\n	for ( int i = 0; i < shadowSamples; ++i )\n	{\n		vec2 poissonUV = generatePoissonSample(poissonData);\n		vec2 sampleUV = uv + poissonUV * filterRadius;\n		float depth = texture2DLod(shadowMap, sampleUV, 0.0).r;\n		sum += step(receiverDepth, depth);\n	}\n	return sum / float(shadowSamples);\n} \nfloat getPenumbra(float dblocker, float dreceiver, float penumbraSize, float penumbraFalloff) {\n	float dist = dreceiver - dblocker;\n	float penumbra = 1.0 - pow(1.0 - dist, penumbraFalloff);\n	return penumbra * penumbraSize;\n}\nfloat PCSSDirectional(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoords, vec4 cameraParams, vec4 softShadowParams) {\n	float receiverDepth = shadowCoords.z;\n	float randomSeed = fractSinRand(gl_FragCoord.xy);\n	int shadowSamples = int(softShadowParams.x);\n	int shadowBlockerSamples = int(softShadowParams.y);\n	float penumbraSize = softShadowParams.z;\n	float penumbraFalloff = softShadowParams.w;\n	int shadowMapSize = textureSize(shadowMap, 0).x;\n	float invShadowMapSize = 1.0 / float(shadowMapSize);\n	invShadowMapSize *= float(shadowMapSize) / 2048.0;\n	float penumbra;\n	if (shadowBlockerSamples > 0) {\n		float avgBlockerDepth = 0.0;\n		int numBlockers = 0;\n		PCSSFindBlocker(TEXTURE_PASS(shadowMap), avgBlockerDepth, numBlockers, shadowCoords.xy, receiverDepth, shadowBlockerSamples, penumbraSize, invShadowMapSize, randomSeed);\n		if (numBlockers < 1)\n			return 1.0f;\n		penumbra = getPenumbra(avgBlockerDepth, shadowCoords.z, penumbraSize, penumbraFalloff);\n	} else {\n		penumbra = penumbraSize;\n	}\n	float filterRadius = penumbra * invShadowMapSize;\n	return PCSSFilter(TEXTURE_PASS(shadowMap), shadowCoords.xy, receiverDepth, shadowSamples, filterRadius, randomSeed);\n}\nfloat getShadowPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec4 softShadowParams, vec3 lightDir) {\n	return PCSSDirectional(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, softShadowParams);\n}\n";

export { shadowSoftPS as default };
