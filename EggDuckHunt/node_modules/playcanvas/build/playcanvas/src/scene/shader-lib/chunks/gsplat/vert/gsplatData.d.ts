declare const _default: "\nuniform highp usampler2D transformA;\nuniform highp sampler2D transformB;\n\n// work values\nuint tAw;\n\n// read the model-space center of the gaussian\nvec3 readCenter(SplatSource source) {\n    // read transform data\n    uvec4 tA = texelFetch(transformA, source.uv, 0);\n    tAw = tA.w;\n    return uintBitsToFloat(tA.xyz);\n}\n\nmat3 quatToMat3(vec4 R) {\n    float x = R.w;\n    float y = R.x;\n    float z = R.y;\n    float w = R.z;\n    return mat3(\n        1.0 - 2.0 * (z * z + w * w),\n              2.0 * (y * z + x * w),\n              2.0 * (y * w - x * z),\n              2.0 * (y * z - x * w),\n        1.0 - 2.0 * (y * y + w * w),\n              2.0 * (z * w + x * y),\n              2.0 * (y * w + x * z),\n              2.0 * (z * w - x * y),\n        1.0 - 2.0 * (y * y + z * z)\n    );\n}\n\nvec4 unpackRotation(vec3 packed) {\n    return vec4(packed.xyz, sqrt(1.0 - dot(packed, packed)));\n}\n\n// sample covariance vectors\nvoid readCovariance(in SplatSource source, out vec3 covA, out vec3 covB) {\n    vec4 tB = texelFetch(transformB, source.uv, 0);\n\n    mat3 rot = quatToMat3(unpackRotation(vec3(unpackHalf2x16(tAw), tB.w)));\n    vec3 scale = tB.xyz;\n    \n    // M = S * R\n    mat3 M = transpose(mat3(\n        scale.x * rot[0],\n        scale.y * rot[1],\n        scale.z * rot[2]\n    ));\n\n    covA = vec3(dot(M[0], M[0]), dot(M[0], M[1]), dot(M[0], M[2]));\n    covB = vec3(dot(M[1], M[1]), dot(M[1], M[2]), dot(M[2], M[2]));\n}\n";
export default _default;
