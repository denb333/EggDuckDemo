declare const _default: "\nuniform highp usampler2D packedTexture;\nuniform highp sampler2D chunkTexture;\n\n// work values\nvec4 chunkDataA;    // x: min_x, y: min_y, z: min_z, w: max_x\nvec4 chunkDataB;    // x: max_y, y: max_z, z: scale_min_x, w: scale_min_y\nvec4 chunkDataC;    // x: scale_min_z, y: scale_max_x, z: scale_max_y, w: scale_max_z\nvec4 chunkDataD;    // x: min_r, y: min_g, z: min_b, w: max_r\nvec4 chunkDataE;    // x: max_g, y: max_b, z: unused, w: unused\nuvec4 packedData;   // x: position bits, y: rotation bits, z: scale bits, w: color bits\n\nvec3 unpack111011(uint bits) {\n    return vec3(\n        float(bits >> 21u) / 2047.0,\n        float((bits >> 11u) & 0x3ffu) / 1023.0,\n        float(bits & 0x7ffu) / 2047.0\n    );\n}\n\nvec4 unpack8888(uint bits) {\n    return vec4(\n        float(bits >> 24u) / 255.0,\n        float((bits >> 16u) & 0xffu) / 255.0,\n        float((bits >> 8u) & 0xffu) / 255.0,\n        float(bits & 0xffu) / 255.0\n    );\n}\n\nconst float norm = 1.0 / (sqrt(2.0) * 0.5);\n\nvec4 unpackRotation(uint bits) {\n    float a = (float((bits >> 20u) & 0x3ffu) / 1023.0 - 0.5) * norm;\n    float b = (float((bits >> 10u) & 0x3ffu) / 1023.0 - 0.5) * norm;\n    float c = (float(bits & 0x3ffu) / 1023.0 - 0.5) * norm;\n    float m = sqrt(1.0 - (a * a + b * b + c * c));\n\n    uint mode = bits >> 30u;\n    if (mode == 0u) return vec4(m, a, b, c);\n    if (mode == 1u) return vec4(a, m, b, c);\n    if (mode == 2u) return vec4(a, b, m, c);\n    return vec4(a, b, c, m);\n}\n\nmat3 quatToMat3(vec4 R) {\n    float x = R.x;\n    float y = R.y;\n    float z = R.z;\n    float w = R.w;\n    return mat3(\n        1.0 - 2.0 * (z * z + w * w),\n              2.0 * (y * z + x * w),\n              2.0 * (y * w - x * z),\n              2.0 * (y * z - x * w),\n        1.0 - 2.0 * (y * y + w * w),\n              2.0 * (z * w + x * y),\n              2.0 * (y * w + x * z),\n              2.0 * (z * w - x * y),\n        1.0 - 2.0 * (y * y + z * z)\n    );\n}\n\n// read center\nvec3 readCenter(SplatSource source) {\n    uint w = uint(textureSize(chunkTexture, 0).x) / 5u;\n    uint chunkId = source.id / 256u;\n    ivec2 chunkUV = ivec2((chunkId % w) * 5u, chunkId / w);\n\n    // read chunk and packed compressed data\n    chunkDataA = texelFetch(chunkTexture, chunkUV, 0);\n    chunkDataB = texelFetch(chunkTexture, chunkUV + ivec2(1, 0), 0);\n    chunkDataC = texelFetch(chunkTexture, chunkUV + ivec2(2, 0), 0);\n    chunkDataD = texelFetch(chunkTexture, chunkUV + ivec2(3, 0), 0);\n    chunkDataE = texelFetch(chunkTexture, chunkUV + ivec2(4, 0), 0);\n    packedData = texelFetch(packedTexture, source.uv, 0);\n\n    return mix(chunkDataA.xyz, vec3(chunkDataA.w, chunkDataB.xy), unpack111011(packedData.x));\n}\n\nvec4 readColor(in SplatSource source) {\n    vec4 r = unpack8888(packedData.w);\n    return vec4(mix(chunkDataD.xyz, vec3(chunkDataD.w, chunkDataE.xy), r.rgb), r.w);\n}\n\nvec4 getRotation() {\n    return unpackRotation(packedData.y);\n}\n\nvec3 getScale() {\n    return exp(mix(vec3(chunkDataB.zw, chunkDataC.x), chunkDataC.yzw, unpack111011(packedData.z)));\n}\n\n// given a rotation matrix and scale vector, compute 3d covariance A and B\nvoid readCovariance(in SplatSource source, out vec3 covA, out vec3 covB) {\n    mat3 rot = quatToMat3(getRotation());\n    vec3 scale = getScale();\n\n    // M = S * R\n    mat3 M = transpose(mat3(\n        scale.x * rot[0],\n        scale.y * rot[1],\n        scale.z * rot[2]\n    ));\n\n    covA = vec3(dot(M[0], M[0]), dot(M[0], M[1]), dot(M[0], M[2]));\n    covB = vec3(dot(M[1], M[1]), dot(M[1], M[2]), dot(M[2], M[2]));\n}\n";
export default _default;
