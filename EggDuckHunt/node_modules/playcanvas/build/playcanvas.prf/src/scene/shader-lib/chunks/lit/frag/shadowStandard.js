var shadowStandardPS = "\nfloat _getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec3 shadowParams) {\n	float z = shadowCoord.z;\n	vec2 uv = shadowCoord.xy * shadowParams.x;\n	float shadowMapSizeInv = 1.0 / shadowParams.x;\n	vec2 base_uv = floor(uv + 0.5);\n	float s = (uv.x + 0.5 - base_uv.x);\n	float t = (uv.y + 0.5 - base_uv.y);\n	base_uv -= vec2(0.5);\n	base_uv *= shadowMapSizeInv;\n	float sum = 0.0;\n	float uw0 = (3.0 - 2.0 * s);\n	float uw1 = (1.0 + 2.0 * s);\n	float u0 = (2.0 - s) / uw0 - 1.0;\n	float u1 = s / uw1 + 1.0;\n	float vw0 = (3.0 - 2.0 * t);\n	float vw1 = (1.0 + 2.0 * t);\n	float v0 = (2.0 - t) / vw0 - 1.0;\n	float v1 = t / vw1 + 1.0;\n	u0 = u0 * shadowMapSizeInv + base_uv.x;\n	v0 = v0 * shadowMapSizeInv + base_uv.y;\n	u1 = u1 * shadowMapSizeInv + base_uv.x;\n	v1 = v1 * shadowMapSizeInv + base_uv.y;\n	sum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));\n	sum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));\n	sum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));\n	sum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));\n	sum *= 1.0f / 16.0;\n	return sum;\n}\nfloat getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n	return _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);\n}\nfloat getShadowSpotPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n	return _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);\n}\nfloat getShadowPCF1x1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n	return textureShadow(shadowMap, shadowCoord);\n}\nfloat getShadowSpotPCF1x1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n	return textureShadow(shadowMap, shadowCoord);\n}\n#ifndef WEBGPU\nfloat getShadowPointPCF3x3(samplerCubeShadow shadowMap, vec4 shadowParams, vec3 dir) {\n	\n	float shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n	float z = 1.0 / float(textureSize(shadowMap, 0));\n	vec3 tc = normalize(dir);\n	mediump vec4 shadows;\n	shadows.x = texture(shadowMap, vec4(tc + vec3( z, z, z), shadowZ));\n	shadows.y = texture(shadowMap, vec4(tc + vec3(-z,-z, z), shadowZ));\n	shadows.z = texture(shadowMap, vec4(tc + vec3(-z, z,-z), shadowZ));\n	shadows.w = texture(shadowMap, vec4(tc + vec3( z,-z,-z), shadowZ));\n	return dot(shadows, vec4(0.25));\n}\nfloat getShadowPointPCF1x1(samplerCubeShadow shadowMap, vec3 shadowCoord, vec4 shadowParams, vec3 lightDir) {\n	float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;\n	return texture(shadowMap, vec4(lightDir, shadowZ));\n}\nfloat getShadowPointPCF3x3(samplerCubeShadow shadowMap, vec3 shadowCoord, vec4 shadowParams, vec3 lightDir) {\n	return getShadowPointPCF3x3(shadowMap, shadowParams, lightDir);\n}\n#endif\n";

export { shadowStandardPS as default };
