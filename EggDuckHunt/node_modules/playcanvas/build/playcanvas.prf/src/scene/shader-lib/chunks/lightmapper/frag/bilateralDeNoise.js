var bilateralDeNoisePS = "\nfloat normpdf3(in vec3 v, in float sigma) {\n	return 0.39894 * exp(-0.5 * dot(v, v) / (sigma * sigma)) / sigma;\n}\nvec3 decodeRGBM(vec4 rgbm) {\n	vec3 color = (8.0 * rgbm.a) * rgbm.rgb;\n	return color * color;\n}\nfloat saturate(float x) {\n	return clamp(x, 0.0, 1.0);\n}\nvec4 encodeRGBM(vec3 color) {\n	vec4 encoded;\n	encoded.rgb = pow(color.rgb, vec3(0.5));\n	encoded.rgb *= 1.0 / 8.0;\n	encoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );\n	encoded.a = ceil(encoded.a * 255.0) / 255.0;\n	encoded.rgb /= encoded.a;\n	return encoded;\n}\nvec3 decode(vec4 pixel) {\n	#if HDR\n		return pixel.rgb;\n	#else\n		return decodeRGBM(pixel);\n	#endif\n}\nbool isUsed(vec4 pixel) {\n	#if HDR\n		return any(greaterThan(pixel.rgb, vec3(0.0)));\n	#else\n		return pixel.a > 0.0;\n	#endif\n}\n#define MSIZE 15\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nuniform vec2 sigmas;\nuniform float bZnorm;\nuniform float kernel[MSIZE];\nvoid main(void) {\n	\n	vec4 pixel = texture2DLod(source, vUv0, 0.0);\n	if (!isUsed(pixel)) {\n		gl_FragColor = pixel;\n		return ;\n	}\n	float sigma = sigmas.x;\n	float bSigma = sigmas.y;\n	vec3 pixelHdr = decode(pixel);\n	vec3 accumulatedHdr = vec3(0.0);\n	float accumulatedFactor = 0.000001;\n	const int kSize = (MSIZE-1)/2;\n	for (int i = -kSize; i <= kSize; ++i) {\n		for (int j = -kSize; j <= kSize; ++j) {\n			\n			vec2 coord = vUv0 + vec2(float(i), float(j)) * pixelOffset;\n			vec4 pix = texture2DLod(source, coord, 0.0);\n			if (isUsed(pix)) {\n				vec3 hdr = decode(pix);\n				float factor = kernel[kSize + j] * kernel[kSize + i];\n				factor *= normpdf3(hdr - pixelHdr, bSigma) * bZnorm;\n				accumulatedHdr += factor * hdr;\n				accumulatedFactor += factor;\n			}\n		}\n	}\n	vec3 finalHDR = accumulatedHdr / accumulatedFactor;\n	#if HDR\n		gl_FragColor = vec4(finalHDR, 1.0);\n	#else\n		gl_FragColor = encodeRGBM(finalHDR);\n	#endif\n}\n";

export { bilateralDeNoisePS as default };
