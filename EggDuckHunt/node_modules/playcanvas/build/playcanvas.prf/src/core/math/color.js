import { math } from './math.js';

class Color {
		clone() {
				var cstr = this.constructor;
				return new cstr(this.r, this.g, this.b, this.a);
		}
		copy(rhs) {
				this.r = rhs.r;
				this.g = rhs.g;
				this.b = rhs.b;
				this.a = rhs.a;
				return this;
		}
		equals(rhs) {
				return this.r === rhs.r && this.g === rhs.g && this.b === rhs.b && this.a === rhs.a;
		}
		set(r, g, b, a) {
				if (a === undefined) a = 1;
				this.r = r;
				this.g = g;
				this.b = b;
				this.a = a;
				return this;
		}
		lerp(lhs, rhs, alpha) {
				this.r = lhs.r + alpha * (rhs.r - lhs.r);
				this.g = lhs.g + alpha * (rhs.g - lhs.g);
				this.b = lhs.b + alpha * (rhs.b - lhs.b);
				this.a = lhs.a + alpha * (rhs.a - lhs.a);
				return this;
		}
		linear(src) {
				if (src === undefined) src = this;
				this.r = Math.pow(src.r, 2.2);
				this.g = Math.pow(src.g, 2.2);
				this.b = Math.pow(src.b, 2.2);
				this.a = src.a;
				return this;
		}
		gamma(src) {
				if (src === undefined) src = this;
				this.r = Math.pow(src.r, 1 / 2.2);
				this.g = Math.pow(src.g, 1 / 2.2);
				this.b = Math.pow(src.b, 1 / 2.2);
				this.a = src.a;
				return this;
		}
		mulScalar(scalar) {
				this.r *= scalar;
				this.g *= scalar;
				this.b *= scalar;
				return this;
		}
		fromString(hex) {
				var i = parseInt(hex.replace('#', '0x'), 16);
				var bytes;
				if (hex.length > 7) {
						bytes = math.intToBytes32(i);
				} else {
						bytes = math.intToBytes24(i);
						bytes[3] = 255;
				}
				this.set(bytes[0] / 255, bytes[1] / 255, bytes[2] / 255, bytes[3] / 255);
				return this;
		}
		fromArray(arr, offset) {
				if (offset === undefined) offset = 0;
				var _arr_offset;
				this.r = (_arr_offset = arr[offset]) != null ? _arr_offset : this.r;
				var _arr_;
				this.g = (_arr_ = arr[offset + 1]) != null ? _arr_ : this.g;
				var _arr_1;
				this.b = (_arr_1 = arr[offset + 2]) != null ? _arr_1 : this.b;
				var _arr_2;
				this.a = (_arr_2 = arr[offset + 3]) != null ? _arr_2 : this.a;
				return this;
		}
		toString(alpha, asArray) {
				var { r, g, b, a } = this;
				if (asArray || r > 1 || g > 1 || b > 1) {
						return r.toFixed(3) + ", " + g.toFixed(3) + ", " + b.toFixed(3) + ", " + a.toFixed(3);
				}
				var s = "#" + ((1 << 24) + (Math.round(r * 255) << 16) + (Math.round(g * 255) << 8) + Math.round(b * 255)).toString(16).slice(1);
				if (alpha === true) {
						var aa = Math.round(a * 255).toString(16);
						if (this.a < 16 / 255) {
								s += "0" + aa;
						} else {
								s += aa;
						}
				}
				return s;
		}
		toArray(arr, offset, alpha) {
				if (arr === undefined) arr = [];
				if (offset === undefined) offset = 0;
				if (alpha === undefined) alpha = true;
				arr[offset] = this.r;
				arr[offset + 1] = this.g;
				arr[offset + 2] = this.b;
				if (alpha) {
						arr[offset + 3] = this.a;
				}
				return arr;
		}
		constructor(r = 0, g = 0, b = 0, a = 1){
				var length = r.length;
				if (length === 3 || length === 4) {
						this.r = r[0];
						this.g = r[1];
						this.b = r[2];
						var _r_;
						this.a = (_r_ = r[3]) != null ? _r_ : 1;
				} else {
						this.r = r;
						this.g = g;
						this.b = b;
						this.a = a;
				}
		}
}
Color.BLACK = Object.freeze(new Color(0, 0, 0, 1));
Color.BLUE = Object.freeze(new Color(0, 0, 1, 1));
Color.CYAN = Object.freeze(new Color(0, 1, 1, 1));
Color.GRAY = Object.freeze(new Color(0.5, 0.5, 0.5, 1));
Color.GREEN = Object.freeze(new Color(0, 1, 0, 1));
Color.MAGENTA = Object.freeze(new Color(1, 0, 1, 1));
Color.RED = Object.freeze(new Color(1, 0, 0, 1));
Color.WHITE = Object.freeze(new Color(1, 1, 1, 1));
Color.YELLOW = Object.freeze(new Color(1, 1, 0, 1));

export { Color };
